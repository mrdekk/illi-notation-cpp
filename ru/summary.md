*Это краткое изложение положений нотации, которое просто представляет правила, но не объясняет их. За толкованием, пожалуйста, обратитесь к полной версии нотации*

*В квадратных скобках приведена структурная нумерация правил нотации для ссылок на них. Предыдущая сквозная нумерация упразднена как неэффективная.*

# Часть 1. Требования к оформлению кода: #

## 1.1. Основные рекомендации ##

**[1.1.1] Любое нарушение нотации позволяется тогда и только тогда, когда это улучшает читаемость.**

**[1.1.2] Правила могут быть нарушены в том и только в том случае, если нарушивший их может четко объяснить, зачем он это сделал.**

## 1.2. Соглашения по наименованию ##

### 1.2.1. Общие соглашения по наименованию ###

**[1.2.1.1] Имена, определяющие типы, должны быть в смешанном стиле заглавных и строчных букв, начинаться с заглавной буквы.**

Пример: `Line, SavingsAccount`

**[1.2.1.2] Имена переменных должны быть в смешанном стиле заглавных и строчных букв, начинаться с прописной буквы.**

Пример: `line, savingsAccount`

**[1.2.1.3] Имена констант (а также имена элементов перечислений) должны писаться полностью заглавными буквами с использованием символа подчеркивания «_» для разделения слов.**

Пример: `MAX_ITERATIONS, COLOR_RED, PI`

**[1.2.1.4] Имена функций и методов должны быть глаголами, быть записаны в смешанном стиле заглавных и строчных букв, начинаться со строчной буквы.**

Пример: `getName( ), computeTotalWidth( )`

**[1.2.1.5] Имена пространств имен должны записываться исключительно строчными буквами.**

Пример: `model::analyzer, io::iomanager, common::math::geometry`

**[1.2.1.6] Имена типов шаблона должны записываться одной заглавной буквой.**

Пример:  

    template < class T > …  
    template < class C, class D > …  

**[1.2.1.7] Аббревиатуры и акронимы не могут быть записаны полностью заглавными буквами, когда используются в наименованиях.**

Пример:  

    exportHtmlSource( ); // NOT: exportHTMLSource( );
    openDvdPlayer( ); // NOT: openDVDPlayer( );

**[1.2.1.8] Глобальные переменные всегда должны предваряться оператором «::».**

Пример: `::mainWindow.open( ), ::applicationContext.getName( )`

**[1.2.1.9] Переменные класса (структуры) должны начинаться с символа подчеркивания и удовлетворять общим требованиям именования переменных.**

Пример:  

    class SomeClass  
    {  
    private:  
        int _length;  
    }

**[1.2.1.10] Единичные временные переменные должны иметь то же имя, что и их тип.**

Пример:  

    void setTopic( Topic* topic )  
        // NOT: void setTopic( Topic* value )  
        // NOT: void setTopic( Topic* aTopic )  
        // NOT: void setTopic( Topic* t )  
    
    void connect( Database* database )  
        // NOT: void connect( Database* db )  
        // NOT: void connect( Database* oracleDB )  

*Не единичные временные переменные имеют роль. Такие переменные именуются комбинацией роли и типа:*

    Point pointStarting, pointCenter;  
    Name nameLogin;  

**[1.2.1.11] Все имена должны быть написаны на английском языке!**

Пример: `fileName; // NOT: filNavn`

**[1.2.1.12] Переменные с большой областью видимости должны иметь длинные имена, в противовес переменным с маленькой областью видимости, для которых предпочтительны короткие имена.**

**[1.2.1.13] Имя объекта должно быть неявным и не использоваться в названии метода.**

Пример: `line.getLength( ); // NOT: line.getLineLength( )`

### 1.2.2. Частные соглашения по наименованию ###

**[1.2.2.1] Слова «set»/«get» должны использоваться тогда, когда получается доступ непосредственно к атрибуту.**

Пример:  

    employee.getName( );  
    employee.setName( name );  
    
    matrix.getElement( 2, 4 );  
    matrix.setElement( 2, 4, value );  

**[1.2.2.2] Слово «compute» должно использоваться тогда, когда в методе что-то вычисляется.**

Пример:  

    valueSet->computeAverage( );  
    matrix->computeInverse( );  

**[1.2.2.3] Слово «find» должно использоваться в методах, где происходит поиск чего-либо.**

Пример:  

    vertex.findNearestVertex( );  
    matrix.findMinElement( );  

**[1.2.2.4] Слово «initiate» должно использоваться тогда, когда объект или концепция инициализируется.**

Пример:  

    printer.initiateFontSet( );  

*Аббревиатура init не должна использоваться.*

**[1.2.2.5] Переменные, представляющие собой элементы пользовательского интерфейса (GUI) должны иметь суффикс типа компонента.**

Пример:  

    mainWindow, propertiesDialog, widthScale, loginText, 
    leftScrollbar, mainForm, fileMenu, minLabel, exitButton, 
    yesToogle …  

**[1.2.2.6] В объектах, представляющих собой коллекции должно использоваться множественное число.**

Пример:  

    vector<Point> points;  
    int values[];  

**[1.2.2.7] Когда требуется определить переменную, содержащую количество чего-либо, мы рекомендуем использовать постфикс «Count».**

Пример: `pointsCount, linesCount`

**[1.2.2.8] Для определения индексных (итерационных) переменных, мы рекомендуем использовать префикс «i» («j», «k», ... ).**

Пример: `iTable, jEmployee`

**[1.2.2.9] Итерационные (индексные) переменные для простых типов должны назваться i, j, k, …**

Пример:  

    for ( int i = 0; i < nTables; ++i )  
    {  
        …  
    }  
    
    for ( vector<MyClass>::iterator i = list.begin( ); i != list.end( ); ++i )  
    {  
        …  
    }  

**[1.2.2.10] Префикс «is» должен применяться только для логических переменных и функций.**

Пример:  

    isSet, isVisible, isFinished( ), isFound( ), isOpen( )

**[1.2.2.11] Общепринятые имена должны соответствовать общепринятым операциям.**

Пример:  

    get/set/put, add/remove,  
    create/destroy, start/stop,  
    insert/delete, increment/decrement,  
    old/new, begin/end, first/last, up/down,  
    min/max, next/prev, open/close, show/hide,  
    suspend/resume, …

**[1.2.2.12] Следует избегать аббревиатур и акронимов в именах.**

Пример:  

    computeAverage( ); // NOT: compAvg( );

**[1.2.2.13] Следует избегать именование указателей.**

Пример:

    Line* line;  
        // NOT: Line* pLine  
        // NOT: Line* linePtr;  

**[1.2.2.14] Следует избегать отрицающих имен логических значений.**

Пример:  

    bool isError; // NOT: isNoError  
    bool isFound; // NOT: isNotFound  

**[1.2.2.15] Имена элементов перечисления должны содержать префикс общего типа.**

Пример:  

    enum Colors  
    {  
        COLOR_RED,  
        COLOR_GREEN,  
        COLOR_BLUE  
    }  

**[1.2.2.16] Классы исключение должны содержать суффикс «Exception».**

Пример:  

    class AccessException  
    {  
        …  
    }  

## 1.3. Именование файлов ##

### 1.3.1. Файлы исходного кода ###

**[1.3.1.1] Название заголовочных файлов должно иметь расширение «.h» (реже «.hpp»). Название файлов реализации должно иметь расширение «.cpp» (для чистого С - «.c» ).**

Пример: `MyClass.h, MyClass.cpp`

**[1.3.1.2] Класс должен быть объявлен в заголовочном файле и определен в файле реализации, имена которых совпадают с именем класса.**

Пример: `MyClass.h, MyClass.cpp`

**[1.3.1.3] Все определения должны находится в файле реализации.**

Пример:  

    class MyClass  
    {  
    public:  
        int getValue( ) { return _value; } // NO!  
        …  
    private:  
        int _value;  
    }  

**[1.3.1.4] Содержимое файла должно укладываться в 80 столбцов.**

**[1.3.1.5] Следует избегать специальные символов, таких как TAB и разрыв страницы.**

**[1.3.1.6] Всегда, когда Вы разбиваете строку на несколько — это должно быть очевидным.**

Пример:  

    totalSum = a + b + c +  
               d + e;  
    
    function ( param1, param2,  
               param3 );
    
    setText( “Long line split”  
             “into to parts” );  
    
    for ( int iTable = 0; iTable < nTables;  
          iTable += tableStep )  
    {  
        …  
    }  

### 1.3.2. Подключение файлов и выражения #include ###

**[1.3.2.1] Заголовочные файлы должны иметь защиту от повторного включения.**

Пример:  

    #ifndef COM_COMPANY_MODULE_CLASSNAME_H  
    #define COM_COMPANY_MODULE_CLASSNAME_H  
    …  
    #endif // COM_COMPANY_MODULE_CLASSNAME_H  

*Никогда нельзя использовать конструкции которые предлагает определенный комплятор (например cl от Microsoft):*

    // NOT: #pragma once

**[1.3.2.2] Операции включения должны быть отсортированы и сгруппированы. Сортировка осуществляется по иерархической позиции файлов в системе начиная с самых низкоуровневых. Следует оставлять пустую строку между группами файлов.**

Пример:  

    #include <fstream>  
    #include <iomanip>  
    
    #include <qt/qbutton.h>  
    #include <qt/qtextfield.h>  
    
    #include “com/company/ui/PropertiesDialog.h”  
    #include “com/company/ui/MainWindow.h”  

**[1.3.2.3] Выражения включения могут находится ТОЛЬКО в начале файла.**

## 1.4. Выражения ##

### 1.4.1. Типы ###

**[1.4.1.1] Типы, которые относятся только к одному определенному файлу, могут быть объявлены внутри него.**

**[1.4.1.2] Части класса должны быть отсортированы по видимости в следующем порядке: public, protected, private. Все спецификаторы должны быть объявлены явно. Не следует писать только спецификаторы, когда секция отсутствует.**

**[1.4.1.3] Преобразование типов должно осуществляться только явно. Никогда не полагайтесь на встроенных механизмы преобразования.**

Пример:  

    floatValue = static_cast< float >( intValue );  
        // NOT: floatValue = intValue  

### 1.4.2. Переменные ###

**[1.4.2.1] Переменные всегда должны определяться там, где объявляются.**

**[1.4.2.2] Переменные никогда не должны иметь двойной смысл.**

**[1.4.2.3] Использование глобальных переменных следует минимизировать.**

**[1.4.2.4] Переменные класса НИКОГДА нельзя объявлять как public.**

**[1.4.2.5] Указатели и ссылки С++ должны находится сразу после типа, нежели перед именем.**

Пример:  
    

    float* x; // NOT: float *x;  
    int& y; // NOT: int &y;  

**[1.4.2.6] Неявная проверка на 0 не должна использоваться. Исключения — логические значения.**

Пример:  

    if ( 0 != linesCount ) // NOT: if ( linesCount )  
    if ( 0.0 != value ) // NOT: if ( value )  

**[1.4.2.7] Переменные должны объявляться в минимально возможной области видимости.**

### 1.4.3. Циклы ###

**[1.4.3.1]  Только выражения контроля цикла могут быть включены в конструкцию for().**

Пример:  

    sum = 0;  
    for ( i = 0; i < 100; ++i )  
        sum += value[ i ];  
    
    // NOT: for ( i = 0, sum = 0; i < 100; ++i ) sum += value[ i ];  

**[1.4.3.2] Переменные цикла должны определяться непосредственно перед циклом.**

Пример:  

    isDone = false;  
    while ( !isDone )  
    {  
        …  
    }  
    
    // NOT: bool isDone = false;  
    //	  …  
    //	  while ( !isDone )  
    //	  {  
    //		  …  
    //	  }  

**[1.4.3.3] Следует избегать циклов do-while.**

**[1.4.3.4] Следует использовать конструкции break и continue с осторожностью.**

**[1.4.3.5] Для бесконечных циклов должно использоваться форма while( true ).**

Пример:  

    while ( true )  
    {  
        …  
    }  
    
    for ( ; ; ) // NO!  
    while ( 1 ) // NO!  

### 1.4.4. Условия ###

**[1.4.4.1] Следует избегать очень больших условий. Вместо этого лучше использовать логическую переменную.**

Пример:  

    bool isFinished = ( iElement < 0 ) || ( iElement > maxElement );  
    bool isRepeatedEntry = iElement = lastElement;  
    if ( isFinished || isRepeatedEntry )  
    {  
        …  
    }  
    
    // NOT:  
    if ( ( iElement < 0 ) || ( iElement > maxElement ) ||  
         iElement == lastElement )  
    {  
        …  
    }  

**[1.4.4.2] Требуемое значение должно находится в части if, ошибочное — в части else.**

Пример:

    bool isOk = readFile( fileName );  
    if ( isOk )  
    {  
        …  
    }  
    else  
    {  
        …  
    }  

**[1.4.4.3] Следует разбивать условия на несколько линий.**

Пример:

    if ( isDone )  
        doCleanup( );  
    
    // NOT: if ( isDone ) doCleanup( );  

**[1.4.4.4] Следует избегать выполнения каких либо операций в условиях.**

Пример:

    File* fileHandle = open( fileName, “w” );  
    if ( NULL == fileHandle )  
    {  
        …  
    }  
    
    // NOT:  
    if ( NULL == ( fileHandle = open( fileName, “w” ) ) )  
    {  
        …  
    }  

### 1.4.5. Прочие требования ###

**[1.4.5.1] Следует избегать использования в коде магических чисел, магических строк и прекодированных включей. Когда необходимо ввести какое-то число — лучше объявить его как именованную константу, элемент перечисления или вообще переменную.**

**[1.4.5.2] Вещественный константы должны быть записаны с десятичной точкой и хотя бы одним знаком после нее.**

Пример:

    double total = 0.0;	// NOT: double total = 0;  
    double speed = 3.0e8;	// NOT: double speed = 3e8;  
    
    double sum = ( a + b ) * 10.0;  

**[1.4.5.3] Вещественные константы должны быть записаны с знаком перед десятичной точкой.**

Пример:

    double total = 0.5; // NOT: double total = .5;  

**[1.4.5.4] Функции всегда должны объявлять возвращаемое значение.**

Пример:

    int getValue( ) // NOT getValue( )

**[1.4.5.5] Нельзя использовать goto.**

**[1.4.5.6] Следует определить макроопределение NULL (или аналогичное) и использовать его для операций с указателями вместо «0».**

## 1.5. Макет и комментарии ##

### 1.5.1. Макет ###

**[1.5.1.1] Принять отступ 4. Организовывать его посредством TAB.**

Пример:

    for ( i = 0; i < nElements; ++i )  
        a[ i ] = 0;  

**[1.5.1.2] Блочные структуры должны придерживаться следующего соглашения.**

Пример:

    while ( !done )  
    {  
        doSomething( );  
        done = moreToDo( );  
    }  
    
    // NOT  
    while ( !done ) {  
        doSomething( );  
        done = moreToDo( );  
    }  
    
    // NOT  
    while ( !done )  
      {  
        doSomething( );  
        done = moreToDo( );  
      }  

**[1.5.1.3] Объявления класса должны быть в следующей форме.**

Пример:

    class SomeClass : public BaseClass  
    {  
    public:  
        …  
    
    protected:  
        …  
    
    private:  
        …  
    };  

**[1.5.1.4] Объявление методов (функций) должны быть в следующей форме**

Пример:

    void someMethod( )  
    {  
        …  
    }  

**[1.5.1.5] Конструкции условия должны быть записаны в следующей форме:**

Пример:

    if ( condition )  
    {  
        statements;  
    }  
    
    if ( condition )  
    {  
        statements;  
    }  
    else  
    {  
        statements;  
    }  
    
    if ( condition )  
    {  
        statements;  
    }  
    else if ( condition )  
    {  
        statements;  
    }  
    else  
    {  
        statements;  
    }  

**[1.5.1.6] Цикл for должен оформляться в следующем виде:**

Пример:

    for ( initialization; condition; update )  
    {  
        statements;  
    }  

**[1.5.1.7] Пустой цикл for должен иметь следующий вид:**

Пример:

    for ( initialization; condition; update ) ;  

**[1.5.1.8] Цикл while должен иметь следующий вид:**

Пример:

    while ( condition )  
    {  
        statements;  
    }  

**[1.5.1.9]* Цикл do-while должен иметь следующий вид:**

Пример:

    do  
    {  
        statements;  
    } while ( condition );  

**[1.5.1.10] Инструкция выбора switch должна иметь следующий вид:**

Пример:

    switch ( condition )  
    {  
    case ABC:  
        statements;  
        // fallthrough  
    
    case DEF:  
        statements;  
        break;  
    
    case XYZ:  
        statements;  
        break;  
    
    default:  
        statements;  
        break;  
    };  

**[1.5.1.11] Инструкция try-catch должна иметь следующий вид:**

Пример:

    try  
    {  
        statements;  
    }  
    catch ( Exception& exception )  
    {  
        statements;  
    }  

**[1.5.1.12] Единичные выражения в блоках if-else, for и while могут быть записаны без блочных скобок.**

Пример:

    if ( condition )  
        statement;  
    
    while ( condition )  
        statement;  
    
    for ( initialization; condition; update )  
        statement;

### 1.5.2. Пробелы ###

**[1.5.2.1] Пробелами должны выделяться: обычные операторы, зарезервированные слова С++, то что следует за запятыми (но не перед запятой — типографское правило), двоеточия (кроме конструкций case), после точки с запятой, круглые скобки, квадратные скобки, угловые скобки.**

Пример:

    a = ( b + c ) * d; // NOT: a=(b+c)*d  
    
    while ( true ) // NOT: while(true)  
    
    doSomething( a, b, c, d ); // NOT: doSomething(a,b,c,d);  
    
    case 100: // NOT: case 100 :  
    
    a = ( bool ) ? b : c;  
    
    for ( i = 0; i < 10; ++i ) // NOT: for(i=0;i<10;++i)  
    
    template< class T > // NOT: template<class T>  
    
    a[ i ] = 10; // NOT: a[i]=10;  

**[1.5.2.2] Логические блоки кода должны разделяться пустой линией.**

Пример:

    Matrix4x4 matrix = new Matrix4x4( );
    
    double cosAngle = Math.cos( angle );  
    double sinAngle = Math.sin( angle );  
    
    matrix.setElement( 1, 1,  cosAngle );  
    matrix.setElement( 1, 2,  sinAngle );  
    matrix.setElement( 2, 1, -sinAngle );  
    matrix.setElement( 2, 2,  cosAngle );  
    
    multiply( matrix );  

**[1.5.2.3] Переменные при объявлении могут быть выравненными.**

Пример:

    AsciiFile* file;  
    int        nPoints;  
    float      x, y;  

**[1.5.2.4] Следует использовать выравнивание всегда — когда это повышает читаемость кода. Иногда даже отступая от некоторых других правил — главное чтоб это не вредило производителности и ошибко-безопасности.**

Пример:

    if      ( a == lowValue )    computeSomething( );  
    else if ( a == mediumValue ) computeSomethingElse( );  
    else if ( a == highValue )   computeSomethingElseYet( );  
    
    value = ( potential        * oilDensity )   / constant1 +  
            ( depth            * waterDensity ) / constant2 +  
            ( zCoordinateValue * gasDensity )   / constant3;  
    
    minPosition     = computeDistance( min,     x, y, z );  
    averagePosition = computeDistance( average, x, y, z );  
    
    switch ( value )  
    {  
    case PHASE_OIL:   strcpy( phase, “oil” );   break;  
    case PHASE_WATER: strcpy( phase, “Water” ); break;  
    case PHASE_GAS:   strcpy( phase, “Gas” );   break;  
    };  

### 1.5.3. Комментарии ###

**[1.5.3.1] Хитрый код должен не комментироваться, а писаться правильно.**

**[1.5.3.2] Все комментарии должны быть написаны на английском языке!**

**[1.5.3.3] Предпочитайте использование комментариев типа «//», вплоть до многострочных комментариев.**

Пример:

    // Comment spanning  
    // more than one line  

**[1.5.3.4] Комментарии должны быть там, где объект которые они комментируют.**

Пример:

    while ( true )  
    {  
        // Do something  
        something( );  
    }  
    
    // NOT!  
    while ( true )  
    // Do something  
    {  
        something( );  
    }  

**[1.5.3.5] Комментарии объявления класса и методов должны следовать соглашениям JavaDoc.**

# Часть 2. Требования к стилю программирования. #

## 2.1. Общие замечания #

**[2.1.1]. см. пункт [1.1.1]**

**[2.1.2]. см. пункт [1.1.2]**

## 2.2. Миграция из С в С++ ##

**[2.2.1] Следует избегать инструкций #define**

Пример:

    const double PI = 3.1415; // NOT: #define PI 3.1415

    template < class T >
    inline const T& max( const T& a, const T& b ) 
    { 
        return ( a > b ) ? a : b; 
    }
    // NOT #define max(a,b) ( (a) > (b) ? (a) : (b) )

**[2.2.2] Следует предпочитать библиотеку iostream вместо stdio.**

Пример:

    #include <iostream> // NOT: #include <stdio>

**[2.2.3] Следует предпочитать приведения типов в стиле С++, вместо С.**

Пример:

    static_cast< double > intValue; // NOT: (double)intValue

**[2.2.4] Для операции с указателями следует определить макро NULL (или аналогичный) и использовать его.**

**[2.2.5] Следует предпочитать ссылки указателям.**

**[2.2.6] Ключевое слово const должно использоваться везде, где только можно.**

**[2.2.7] Не следует использовать передачу объектов «по значению».**

Пример:

    myMethod( const SomeClass& class ); // NOT: myMethod( SomeClass class )

**[2.2.8] Следует избегать переменного числа аргументов функции (…).**

**[2.2.9] Следует использовать конструкции new и delete вместо malloc, realloc, free.**

## 2.3. Конструкторы, деструкторы и операторы присваивания ##

**[2.3.1] В классах с динамическим управление памятью всегда определять копирующий конструктор и оператор присваивания.**

**[2.3.2] Оператор присваивания всегда должен возвращать ссылку на *this.**

Пример:

    MyClass& MyClass::operator = ( const MyClass& rhs )
    {
        …
        return *this;
    }

**[2.3.3] Оператор присваивания всегда должен проверять на присваивание самому себе.**

Пример:

    MyClass& MyClass::operator = ( const MyClass& rhs )
    {
        if ( this != &rhs )
        {
            …
        }
    
        return *this;
    }

    MyClass& MyClass::operator = ( const MyClass& rhs )
    {
        if ( *this != rhs )
        {
            …
        }
    
        return *this;
    }

**[2.3.4] Оператор присваивания класса наследника должен явно производить присваивание через базовый класс.**

Пример:

    Derived& Derived::operator = ( const Derived& rhs )
    {
        if ( this != &rhs )
        {
            Base::operator = ( rhs );
            …
        }
    
        return *this;
    }

**[2.3.5] В конструкторах следует предпочитать инициализацию вместо присваивания.**

**[2.3.6] Деструктор должен быть виртуальным только тогда, когда класс содержит виртуальные методы. (Либо этот класс вообще не может быть базовым классом).**

**[2.3.7] Конструкторы объектов принимающих один аргумент должны быть объявлены с ключевым словом explicit, для исключения случаев неявного ненужного приведения.**

## 2.4. Операторы ##

**[2.4.1] Оба оператора «!=» и «==» должны определяться всегда, когда нужен хотя бы один из них.**

Пример:

    bool C::operator != ( const C& lhs )
    {
        return !( this == lhs );
    }

**[2.4.2] Нельзя перегружать операторы «&&», «||» и «,».**

## 2.5. Наследование ##

**[2.5.1] Отношение «есть разновидность» должно быть смоделировано через наследование, отношение «имеет» - через содержание.**

Пример:

    class B : public A // B “is-a” A
    {
        …
    }

    class B
    {
        …
    
    private:
        A _a; // B “has-a” A
    }

**[2.5.2] Не виртуальные методы нельзя переопределять в подклассе.**

**[2.5.3] Наследованные параметры по умолчанию переопределять нельзя.**

**[2.5.4] Следует избегать закрытого наследования.**

Пример:

    class C     // NOT: class C: private B
    {           //      {
        …       //          …
    private:    //      }
        B _b;
    }

*НЕЛЬЗЯ использовать защищенное наследование.*

**[2.5.5] Следует избегать обратного преобразования (downcasting).**

Пример:

    derived = static_cast< DerivedClass* > base;

**[2.5.6] Следует избегать использование полиморфизма в массивах.**

Пример:

    class Bst { … }
    class BstBalanced : public Bst { … }

    void printBstArray( ostream& s, const Bst array[], int numElements )
    {
        for ( int i = 0; i < numElements; ++i ) s << array[ i ];
    }

    Bst bstArray[ 10 ];
    printBstArray( cout, bstArray, 10 ); // OK

    BstBalanced bstBalancedArray[ 10 ];
    printBstArray( cout, bstBalancedArray, 10 ); // FAIL!

## 2.6. Исключения ##

**[2.6.1] Если возникает необходимость работы с исключениями, то обрабатывать их по ссылке. Вообще — следует избегать работы с исключениями.**

Пример:

    try
    {
        …
    }
    catch ( Exception& exception )
    {
        …
    }

## 2.7. Разное ##

**[2.7.1] Следует четко проводить различие между методами класса, внешними функциями и дружественными методами.**

**[2.7.2] Неявно генерируемые методы, которые не используются, должны быть явно запрещены.**

Пример:

    class C
    {
        …
    
    private:
        C& operator = ( const C& rhs ); // Don't define
    }

**[2.7.3] Следует предпочитать объекты типа Singleton глобальным переменным.**

Пример:

    class C
    {
    public:
        static const C* getInstance( )
        {
            if ( !_instance ) 
                _instance = new C( );
            
            return _instance;
        }

    private:
        C( );
        static C* _instance; // Defined in the source file
    }

**[2.7.4] Функции, которые могут быть реализованы с использованием открытого интерфейса класса, лучше не делать методами.**

**[2.7.5] Открытый метод не должен возвращать неконстантную ссылку или указатель на поле класса.**

**[2.7.6] Возвращаемый тип функции всегда должен быть явно объявлен.**

Пример:

    int function( )     // NOT: function( )
    {                   //      {
        …               //          …
    }                   //      }

**[2.7.7] При определении константы на указатель в заголовочном файле, необходимо сам указатель также объявлять как константный:**

    const char* const someString = “This is a string”;

**[2.7.8] Избегать перегрузки по численному типу и указателю.**

    void f( int x );
    void f( string* str );
    f( 0 ); // Что будет вызвано? f(int) или f(string*).

**[2.7.9] Следует избегать создание потенциальной неоднозначности:**

    class B;
    
    class A
    {
    public:
        A( const B& );
    };

    class B
    {
    public:
        operator A( ) const;
    };

**[2.7.10] Различайте наследование и шаблоны**

*При выборе того, будет ли класс реализовываться посредством шаблонов или наследования следует руководствоваться следующими соображениями:*

1. шаблоны должны использоваться для генерации семейств классов, тип объектов которых не влияет на поведение функций этих классов;
2. наследование должно использоваться для создания семейств классов, тип объектов которых влияет на поведение функций создаваемых классов.