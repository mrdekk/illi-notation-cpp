*В квадратных скобках приведена структурная нумерация правил нотации для ссылок на них. Предыдущая сквозная нумерация упразднена как неэффективная.*

# Преамбула #

*Язык С++ известен своей мощью. Однако как и у любой силы, мощь С++ имеет и обратную сторону, так при не очень умелом обращении легко можно получить в лучшем случае неработающий продукт. Поэтому возникает необходимость в документе, который бы решал несколько задач. Первая из них состоит в управлении сложностью, ведь чем проще - тем легче понимать, а следовательно и меньше ошибок. Вторая задача стоит в унификации стиля программистов, участвующих в проекте. Когда каждый программист в проекте сам себе художник, это негативно складывается на качестве кода проекта в целом. Каждый из этих программистов работает над общим делом, а следовательно должен легко разбираться в коде, написанном другими людьми. И, наконец, третья задача - обговорить правила игры по использованию некоторых возможностей самого языка С++. Как известно С++ богат своими возможностями, но некоторые из них могут быть очень опасны, и только истинным ниндзя позволяется использовать их. Поэтому иногда мы настоятельно запрещаем использование некоторых фич, все для улучшения качества кода.*

# Часть 1. Требования к оформлению кода: #

## 1.1. Основные рекомендации ##

**[1.1.1] Любое нарушение нотации позволяется тогда и только тогда, когда это улучшает читаемость либо понижает сложность.**

*Как уже было указано выше в преамбуле - основная задача этого документа - уменьшить сложность и улучшить читаемость программ. Мы не можем в одном документе охватить полностью все аспекты, которые могут появляться в ходе программирования на С++, поэтому стараемся дать общие рекомендации. Иногда отступления возможны, но следует понимать, что это не роскошь или преференция.*

**[1.1.2] Правила могут быть нарушены в том и только в том случае, если нарушивший их может четко объяснить, зачем он это сделал.**

*Прежде чем нарушать нотацию стоит с ней ознакомится. Все предложенные правила "выстраданы" на собственном опыте, и мы уверяем Вас, они того стоят. Однако, если вдруг мы где-то ошиблись или Вы настолько ниндзя, что глубоко понимаете правила и знаете некоторые способы их обхода, которые впрочем не нарушают основной цели нотации (меньшая сложность и большая читаемость), то Вы вправе поступить по своему. Но только в том случае, если Вы полностью понимаете и отдаете себе отчет в последствиях.*

**[1.1.3] Правила не "вырублены в граните" а являются предметом обсуждения.**

*Все предлагаемые правила - это выжимки из нашего опыта. Однако и мы тоже люди и можем ошибаться. Кроме того, мы можем чего-то и не знать, С++ столь многообразен и многолик. Поэтому мы принимаем аргументированные возражения и предложения. Если аргументация нас устроит - мы внесем поправки в нотацию.*

## 1.2. Соглашения по наименованию ##

### 1.2.1. Общие соглашения по наименованию ###

**[1.2.1.1] Имена, определяющие типы, должны быть в смешанном стиле заглавных и строчных букв, начинаться с заглавной буквы.**

Пример: `Line, SavingsAccount`

*Данное правило следует из общих правил наименований принятых в сообществе С++.*

**[1.2.1.2] Имена переменных должны быть в смешанном стиле заглавных и строчных букв, начинаться с прописной буквы.**

Пример: `line, savingsAccount`

*Данное правило следует из общих правил наименований принятых в сообществе С++.*

**[1.2.1.3] Имена констант (а также имена элементов перечислений) должны писаться полностью заглавными буквами с использованием символа подчеркивания «_» для разделения слов.**

Пример: `MAX_ITERATIONS, COLOR_RED, PI`

*Данное правило следует из общих правил наименований принятых в сообществе С++. В общем случае же использование подобных констант должно быть минимизировано. Во многих случаях, сделать функцию, которая возвращает значение, будет лучшим выбором. С учетом C++11:*

    constexpr int getMaxIterations( )
    {
        return 25;
    }

*Эта форма также легка в прочтении, но кроме того создает общий интерфейс между значениями класса.*

**[1.2.1.4] Имена функций и методов должны быть глаголами, быть записаны в смешанном стиле заглавных и строчных букв, начинаться со строчной буквы.**

Пример: `getName( ), computeTotalWidth( )`

*Данной правило следует из общих правил наименований принятых в сообществе С++. Вообще данное правило идентично с правилом наименования переменных, однако, во-первых, переменные и функции имеют разную природу, во-вторых, современные средства разработки (IDE) позволяют их различать. Кроме того, переменные необходимо именовать именами существительными, а функции - глаголами.*

**[1.2.1.5] Имена пространств имен должны записываться исключительно строчными буквами.**

Пример: `model::analyzer, io::iomanager, common::math::geometry`

*Это обычная практика, принятая в сообществе С++.*

**[1.2.1.6] Имена типов шаблона следует именовать также как и классы.**

Пример:  

    template < class Type > …  
    template < class Key, class Value > …  

*Это позволяет, во-первых, использовать идентификатор шаблона в коде как обычный класс (в то же время IDE показывают то, что это параметры шаблона). Во-вторых, это сразу дает представление о том, что ожидается в качестве этого параметра. Практику именования папараметров одной заглавной буквой следует избегать.*

**[1.2.1.7] Аббревиатуры и акронимы не могут быть записаны полностью заглавными буквами, когда используются в наименованиях.**

Пример:  

    exportHtmlSource( ); // Но не: exportHTMLSource( );
    openDvdPlayer( ); // Но не: openDVDPlayer( );

*Использование всех заглавных букв будет создавать конфликты с правилами, которые были указаны выше. Например переменные таких типов по правилам должны были бы называться dVD, hTML и т.д. что очевидно не очень хорошо читается. Вторая проблема представлена в примере — когда такое имя соединяется с другим, читаемость кода резко понижается.*

**[1.2.1.8] Глобальные переменные всегда должны предваряться оператором «::».**

Пример: `::mainWindow.open( ), ::applicationContext.getName( )`

*В общем случае следует избегать использования глобальных переменных — лучше использовать объекты типа singleton.*

**[1.2.1.9] Переменные класса (структуры) должны начинаться с символа подчеркивания и удовлетворять общим требованиям именования переменных.**

Пример:  

    class SomeClass  
    {  
    private:  
        int _length;  
    }

*В отличие от имени и типа, область видимости переменной — одна из важнейших особенностей. Отличие переменных класса путем добавления символа подчеркивания позволяет легко отделять их от локальных (временных) переменных. Это важно, потому что поля класса имеют большее значение, нежели локальные переменные методов, поэтому должны отделяться специальным образом.*

*Побочные эффект такого наименование проявляется в элегантном решении проблемы с поиском подходящих имен для переменных сеттеров и конструкторов:*

    void setDepth( int depth )  
    {  
        _depth = depth;  
    }

*Вопрос где ставить подчеркивание — сначала или вконце? Обе практики широко используются. На наш взгляд использование префикса предпочтительнее — ввиду большего обращения внимания программиста.*

*Следует однако понимать, что выделение переменных по областям видимости иногда является спорным вопросом. Однако, такая практика получает все большее распространение и становится все более и более похожей на правила в профессиональной среде.*

**[1.2.1.10] Все имена должны быть написаны на английском языке!**

Пример: `fileName; // Но не: filNavn`

*Английский язык — предпочитаемый язык для интернациональной разработки. Если не знаете как русское (или на ином языке) слово будет по английски — НЕ ПОЛЕНИТЕСЬ СХОДИТЬ на translate.google.ru и перевести слово. Непременным должно быть и то, что Вы знаете что значит слово.*

**[1.2.1.11] Имя объекта должно быть неявным и не использоваться в названии метода.**

Пример: `line.getLength( ); // Но не: line.getLineLength( )`

*Последнее кажется логичным при объявлении класса, однако излишне при использование, в чем можно убедится в примере*

### 1.2.2. Частные соглашения по наименованию ###

**[1.2.2.1] Слова «set»/«get» должны использоваться тогда, когда получается доступ непосредственно к атрибуту.**

Пример:  

    employee.getName( );  
    employee.setName( name );  
    
    matrix.getElement( 2, 4 );  
    matrix.setElement( 2, 4, value );  

*Обычная практика, принятая в сообщество С++. В языке Java это соглашение более или менее является стандартным. Иногда для доступа к внутренней переменной класса можно использовать геттер без префикса get, как например:*

	employee.setName( name )
	employee.name( )
	
Но
	
	matrix.setElement( 2, 4, value )
	matrix.getElement( 2, 4 )
	
**[1.2.2.2] Используйте слово «initiate» для методов инициализаторов, «shutdown» для деинициализаторов.**

Пример:

	printer.initiate( )
	printer.shutdown( )
	
*Аббревиатуру init лучше использовать, когда в названии метода есть что-то еще.*

Пример:

	printer.initiate( )
	printer.initFontSet( ... ) 


**[1.2.2.3] Переменные, представляющие собой элементы пользовательского интерфейса (GUI) должны иметь суффикс типа компонента.**

Пример:  

    mainWindow, propertiesDialog, widthScale, loginText, 
    leftScrollbar, mainForm, fileMenu, minLabel, exitButton, 
    yesToogle …  

*Это лучше, чем использовать префикс, т.к. дает указание на функциональное предназначение объекта, нежели на его тип.*

**[1.2.2.4] В объектах, представляющих собой коллекции должно использоваться множественное число.**

Пример:  

    vector<Point> points;  
    int values[];  

*Кажется логичным для всех, кто знает английский язык. Кроме того, позволяет писать красивые и краткие инструкции циклов, вида:*

Пример

	for ( Point point : Points )

**[1.2.2.5] Когда требуется определить переменную, содержащую количество чего-либо, мы рекомендуем использовать постфикс «Count».**

Пример: `pointsCount, linesCount`

*На наш взгляд увеличивает читаемость кода*

**[1.2.2.6] Немного об индексных переменных**

*Вообще индексные переменные следует именовать привычными для многих программистов i, j, k, ... Однако, это допустимо только в тех случаях, когда тело цикла занимает не больше 5-10 строк. В противном случае становится очень сложно понять, что обозначает эта индексная переменная. В таких случаях мы рекомендуем использовать переменные с префиксом i, j, k в качестве индексных.*
 
Пример: 

	for ( int i = 0; i < tablesCount; ++i )
	{
		< 5 - 10 строк кода >
	}
	
	for ( int iPerson = 0; iPerson < personCount; ++iPerson )
	{
		< большой блок кода >
	}

**[1.2.2.7] Общепринятые имена должны соответствовать общепринятым операциям.**

Пример:  

    get/set/put, add/insert/remove,  
    create/destroy, start/stop, initiate/shutdown,  
    inc(rement)/dec(rement),  
    old/new, begin/end, first/last, up/down,  
    min/max, next/prev, open/close, show/hide,  
    suspend/resume, …

*Уменьшает сложность благодаря симметрии.*

**[1.2.2.8] Следует избегать в именах аббревиатур и акронимов которы не являются общеупотребимыми.**

Пример:  

    computeAverage( ); // NOT: compAvg( );

*Можно использовать общеупотребимые аббревиатуры.*

**[1.2.2.9] Следует избегать именование указателей.**

Пример:

    Line* line;  
        // Но не: Line* pLine  
        // Но не: Line* linePtr;  

*Многие переменные в С/С++ являются указателями, поэтому иногда это правило сложно выполнить. Современные средства разработки позволяют выделать указатели из общего числа имен. Только если реальный тип объекта имеет существенное значение, указатель можно выделить в имени.*

**[1.2.2.10] Следует избегать отрицающих имен логических значений.**

Пример:  

    bool isError; // Но не: isNoError  
    bool isFound; // Но не: isNotFound  

*Проблема возникает тогда, когда подобное имя используется рядом с оператором «не», поэтому результат получается дважды отрицающим. Сразу не ясно что значит «!isNotFound».*

**[1.2.2.11] Имена элементов перечисления должны содержать префикс общего типа.**

Пример:  

    enum Colors  
    {  
        COLOR_RED,  
        COLOR_GREEN,  
        COLOR_BLUE  
    }  

*Дополнительная информация позволяет понять где находится объявление, какие константы с каким связаны, а также какую концепцию представляют константы.*

*Важно. Имя типа перечисления должно быть множественным числом, как enum Colors {…}. Единственное число enum Color {…} может выглядеть как объявление типа, но глупо в использовании.*

*Если Вы можете использовать стандарт С++11, то лучшим выбором будет использование типизированных перечислений:*

	enum class Colors
	{
		Red,
		Green,
		Blue
	}

**[1.2.2.12] Классы исключение должны содержать суффикс «Exception».**

Пример:  

    class AccessException  
    {  
        …  
    }  

*Классы исключений не являются главной частью архитектуры приложения, и именование их подобных образом позволяет выделять их из других классов.*

## 1.3. Именование файлов ##

### 1.3.1. Файлы исходного кода ###

**[1.3.1.1] Название заголовочных файлов должно иметь расширение «.h» (реже «.hpp»). Название файлов реализации должно иметь расширение «.cpp» (для чистого С - «.c» ).**

Пример: `MyClass.h, MyClass.cpp`

*Общепринятый стандарт С++.*

**[1.3.1.2] Класс должен быть объявлен в заголовочном файле и определен в файле реализации, имена которых совпадают с именем класса.**

Пример: `MyClass.h, MyClass.cpp`

*Данное соглашение призвано облегчить поиск файлов классов по имени. Единственное исключение из этого правила состоит в том, что шаблонные классы должно и объявляться и определяться в заголовочном файле.*

### 1.3.2. Подключение файлов и выражения #include ###

**[1.3.2.1] Заголовочные файлы должны иметь защиту от повторного включения.**

Пример:  

    #ifndef COM_COMPANY_MODULE_CLASSNAME_H  
    #define COM_COMPANY_MODULE_CLASSNAME_H  
    …  
    #endif // COM_COMPANY_MODULE_CLASSNAME_H  

*Конструкция нужна для исключения ошибок компиляции при повторном включении. Соглашение по наименованию использует расположение файла в дереве исходных кодов и предотвращает конфликт имен.*

*Никогда нельзя использовать конструкции которые предлагает определенный комплятор (например cl от Microsoft):*

    // Нельзя: #pragma once

**[1.3.2.2] Операции включения должны быть отсортированы и сгруппированы. Сортировка осуществляется по иерархической позиции файлов в системе начиная с самых низкоуровневых. Следует оставлять пустую строку между группами файлов.**

Пример:  

    #include <fstream>  
    #include <iomanip>  
    
    #include <qt/qbutton.h>  
    #include <qt/qtextfield.h>  
    
    #include “com/company/ui/PropertiesDialog.h”  
    #include “com/company/ui/MainWindow.h”  

*Кроме того, что данное соглашение позволяет читающему увидеть отдельные файлы, оно также дает понимание того, какие модули используются.*

**[1.3.2.3] Выражения включения могут находится ТОЛЬКО в начале файла.**

*Обычная практика. Позволяет избежать различных побочных эффектов компиляции, когда операции включения скрыты где-то в исходном коде.*

## 1.4. Выражения ##

### 1.4.1. Типы ###

**[1.4.1.1] Части класса должны быть отсортированы по видимости в следующем порядке: public, protected, private. Все спецификаторы должны быть объявлены явно. Не следует писать только спецификаторы, когда секция отсутствует.**

*Правило сортировки - «самые доступные первыми». Это надо для того, чтобы человек, который просто хочет использовать класс остановился при прочтении когда дойдет до секций protected/private.*

**[1.4.1.2] Преобразование типов должно осуществляться только явно. Никогда не полагайтесь на встроенных механизмы преобразования.**

Пример:  

    floatValue = static_cast< float >( intValue );  
        // Но не: floatValue = intValue  

*Благодаря этому соглашению можно избежать использование других типов. Следует помнить, что в С++ можно перегрузить любой оператор, в том числе присваивания и неявного приведения типов — поэтому неявное приведение может привести совершенно не к тем результатам, которые хотелось.*

### 1.4.2. Переменные ###

**[1.4.2.1] Переменные всегда должны определяться там, где объявляются.**

*Это правило направлено на то, чтобы переменные были валидными всегда. Иногда это сделать невозможно, как например*

    int x, y, z;  
    getCenter( &x, &y, &z );  

*В таких случаях разрешает оставить их неинициализированными вместо того, чтобы давать им какие-нибудь посторонние значения.*

**[1.4.2.2] Использование глобальных переменных следует минимизировать.**

*В С++ нет явной необходимости в использовании глобальных переменных. Аналогичное верно и для глобальных функций или переменных области видимости файла.*

**[1.4.2.3] Переменные класса НИКОГДА нельзя объявлять как public.**

*Концепция сокрытия информации и инкапсуляции в С++ нарушается, когда появляются открытые переменные. Используйте private переменные и функции аксессоры. Единственное исключение из этого файла — классы представляющие собой исключительно структуры данных, без поведения (т.е. структуры языка Сб POD типы). В таком случае следует делать переменные класса открытыми.*

*Внимание. Ключевое слово struct оставлено в С++ для совместимости с С и только. В С++ нет особого различия между struct и class. Поэтому следует использовать struct только тогда, когда это простая структура данных без поведения (функций).*

**[1.4.2.4] Указатели и ссылки С++ должны находится сразу после типа, нежели перед именем.**

Пример:  
    

    float* x; // Но не: float *x;  
    int& y; // Но не: int &y;  

*Указательность и ссылочность — это скорее свойство типа, нежели имени. Однако будте внимательны:*

	float* x, y; // указателем будет только x !!!

**[1.4.2.5] Переменные должны объявляться в минимально возможной области видимости.**

*Сохранение операций над переменной в небольщой области видимости увеличивает контроль над прямыми и побочными эффектами использования переменной.*

### 1.4.3. Циклы ###

**[1.4.3.1]  Только выражения контроля цикла могут быть включены в конструкцию for().**

Пример:  

    sum = 0;  
    for ( i = 0; i < 100; ++i )  
        sum += value[ i ];  
    
    // Но не: for ( i = 0, sum = 0; i < 100; ++i ) sum += value[ i ];  

*Улучшает читаемость и возможность поддержки. Проводит четкую грань между управляющими и обрабатываемыми переменными.*

**[1.4.3.2] Переменные цикла должны определяться непосредственно перед циклом.**

Пример:  

    isDone = false;  
    while ( !isDone )  
    {  
        …  
    }  
    
    // Но не: 
    //	  bool isDone = false;  
    //	  …  
    //	  while ( !isDone )  
    //	  {  
    //		  …  
    //	  }  


**[1.4.3.3] Для бесконечных циклов должно использоваться форма while( true ).**

Пример:  

    while ( true )  
    {  
        …  
    }  
    
    for ( ; ; ) // NO!  
    while ( 1 ) // NO!  

*Проверка на 1 ненужна и непонятна. Форма for (;;) не читаема, и не видится как бесконечный цикл.*

### 1.4.4. Условия ###

**[1.4.4.1] Следует избегать очень больших условий. Вместо этого лучше использовать логическую переменную.**

Пример:  

    bool isFinished = ( iElement < 0 ) || ( iElement > maxElement );  
    bool isRepeatedEntry = iElement == lastElement;  
    if ( isFinished || isRepeatedEntry )  
    {  
        …  
    }  
    
    // Но не:  
    if ( ( iElement < 0 ) || ( iElement > maxElement ) ||  
         iElement == lastElement )  
    {  
        …  
    }  

*Благадаря присваиванию логическим переменным — получаем автоматическое документирование кода. Такая конструкция легка в прочтении, понимании и поддержке.*

**[1.4.4.2] Следует разбивать условия на несколько линий.**

Пример:

    if ( isDone )  
        doCleanup( );  
    
    // Но не: if ( isDone ) doCleanup( );  

*Это нужно для целей отладки. Когда написано в одну строку сложно определить дебаггером — истинно условие или ложно.*

**[1.4.4.3] Следует избегать выполнения каких либо операций в условиях.**

Пример:

    File* fileHandle = open( fileName, “w” );  
    if ( NULL == fileHandle )  
    {  
        …  
    }  
    
    // Но не:  
    if ( NULL == ( fileHandle = open( fileName, “w” ) ) )  
    {  
        …  
    }  

*Условия с выполнение операций в них очень сложны в прочтении. Также не следует забывать и о возможных ошибках из-за неправильной расстановки знаков «=». Кроме того, оптимизация условия может просто устранить вызов операции, и он никогда не случится*

### 1.4.5. Прочие требования ###

**[1.4.5.1] Следует избегать использования в коде магических чисел, магических строк и прекодированных включений. Когда необходимо ввести какое-то число — лучше объявить его как именованную константу, элемент перечисления или вообще переменную.**

*Если значение не имеет какого-либо важного самостоятельного значения, введение именованной константы повышает читаемость кода. Другой подход состоит в введении метода, который возвращает требуемое значение.*

**[1.4.5.2] Вещественный константы должны быть записаны с десятичной точкой и хотя бы одним знаком после нее.**

Пример:

    double total = 0.0;	// Но не: double total = 0;  
    double speed = 3.0e8;	// Но не: double speed = 3e8;  
    
    double sum = ( a + b ) * 10.0;  

*Это подчеркивает различную природу целых и вещественных чисел. Математически эти две модели различны и имеют несовпадающие концепции.*

**[1.4.5.3] Вещественные константы должны быть записаны с знаком перед десятичной точкой.**

Пример:

    double total = 0.5; // Но не: double total = .5;  

*Система чисел и выражений в С++ заимствована из математики, поэтому следует следовать математическим соглашениям. Также, 0.5 куда более читаемо, нежели .5. Также это исключает путаницу с целочисленным 5.*

**[1.4.5.4] Функции всегда должны объявлять возвращаемое значение.**

Пример:

    int getValue( ) // NOT getValue( )

*Если не задано явно, С++ считает что тип возвращаемого значения — int. Программисты должны избегать использование этой возможности, потому что начинающие программисты могут про нее не знать.*

**[1.4.5.5] Нельзя использовать goto.**

*Выражения goto нарушают идеи структурированного кода. Если Вам все же нужен сложный выход - обратите внимание на конструкцию `do { … break; } while ( … )`*

**[1.4.5.6] Следует определить макроопределение NULL (или аналогичное) и использовать его для операций с указателями вместо «0».**

*Улучшает читаемость кода.*

## 1.5. Макет и комментарии ##

### 1.5.1. Макет ###

**[1.5.1.1] Принять отступ 4. Организовывать его посредством TAB.**

Пример:

    for ( i = 0; i < nElements; ++i )  
        a[ i ] = 0;  

*Отступ в 1 мал для отображения структуры кода. Отступы более 4 могут повлечь нечитаемость глубоко вложенных конструкций и увеличить шанс разбиение строки. Обычно употребимые отступы 2 и 4. Следует придерживаться 4.*

**[1.5.1.2] Блочные структуры должны придерживаться следующего соглашения.**

Пример:

    while ( !done )  
    {  
        doSomething( );  
        done = moreToDo( );  
    }  
    
    // Но не  
    while ( !done ) {  
        doSomething( );  
        done = moreToDo( );  
    }  
    
    // Но не  
    while ( !done )  
      {  
        doSomething( );  
        done = moreToDo( );  
      }  

**[1.5.1.3] Объявления класса должны быть в следующей форме.**

Пример:

    class SomeClass : public BaseClass  
    {  
    public:  
        …  
    
    protected:  
        …  
    
    private:  
        …  
    };  

*Это соглашение наследует предыдущее.*

**[1.5.1.4] Объявление методов (функций) должны быть в следующей форме**

Пример:

    void someMethod( )  
    {  
        …  
    }  

*Это соглашение наследует правило [1.5.1.2].*

**[1.5.1.5] Конструкции условия должны быть записаны в следующей форме:**

Пример:

    if ( condition )  
    {  
        statements;  
    }  
    
    if ( condition )  
    {  
        statements;  
    }  
    else  
    {  
        statements;  
    }  
    
    if ( condition )  
    {  
        statements;  
    }  
    else if ( condition )  
    {  
        statements;  
    }  
    else  
    {  
        statements;  
    }  

*Также наследуется общее правило оформления.*

**[1.5.1.6] Цикл for должен оформляться в следующем виде:**

Пример:

    for ( initialization; condition; update )  
    {  
        statements;  
    }  

**[1.5.1.7] Пустой цикл for должен иметь следующий вид:**

Пример:

    for ( initialization; condition; update ) ;  

**[1.5.1.8] Цикл while должен иметь следующий вид:**

Пример:

    while ( condition )  
    {  
        statements;  
    }  

**[1.5.1.9]* Цикл do-while должен иметь следующий вид:**

Пример:

    do  
    {  
        statements;  
    } while ( condition );  

**[1.5.1.10] Инструкция выбора switch должна иметь следующий вид:**

Пример:

    switch ( condition )  
    {  
    case ABC:  
        statements;  
        // fallthrough  
    
    case DEF:  
        statements;  
        break;  
    
    case XYZ:  
    {
        statements;  
        ... // очень много выражений
        statements; 
        break;  
    }
    
    default:  
        statements;  
        break;  
    };  

**[1.5.1.11] Инструкция try-catch должна иметь следующий вид:**

Пример:

    try  
    {  
        statements;  
    }  
    catch ( Exception& exception )  
    {  
        statements;  
    }  

### 1.5.2. Пробелы ###

**[1.5.2.1] Пробелами должны выделяться: обычные операторы, зарезервированные слова С++, то что следует за запятыми (но не перед запятой — типографское правило), двоеточия (кроме конструкций case), после точки с запятой, круглые скобки, квадратные скобки, угловые скобки.**

Пример:

    a = ( b + c ) * d; // Но не: a=(b+c)*d  
    
    while ( true ) // Но не: while(true)  
    
    doSomething( a, b, c, d ); // Но не: doSomething(a,b,c,d);  
    
    case 100: // Но не: case 100 :  
    
    a = ( bool ) ? b : c;  
    
    for ( i = 0; i < 10; ++i ) // Но не: for(i=0;i<10;++i)  
    
    template< class T > // Но не: template<class T>  
    
    a[ i ] = 10; // Но не: a[i]=10;  

*Следует показывать отдельные объекты путем выделения их пробелами. Сложно дать полный список рекомендаций по этому правилу.* 

**[1.5.2.2] Логические блоки кода должны разделяться пустой линией.**

Пример:

    Matrix4x4 matrix = new Matrix4x4( );
    
    double cosAngle = Math.cos( angle );  
    double sinAngle = Math.sin( angle );  
    
    matrix.setElement( 1, 1,  cosAngle );  
    matrix.setElement( 1, 2,  sinAngle );  
    matrix.setElement( 2, 1, -sinAngle );  
    matrix.setElement( 2, 2,  cosAngle );  
    
    multiply( matrix );  

*Улучшает читаемость кода благодаря логическому разделению блоков кода.*

### 1.5.3. Комментарии ###

**[1.5.3.1] Хитрый код должен не комментироваться, а писаться правильно.**

*В общем, использование комментариев следует минимизировать путем создания самодокументируемого кода путем выбора правильных имен и четкой логической структурой.*

*Комментировать следует только контракт интерфейсов, и лучше в системах документирования кода (Wiki, например).*

**[1.5.3.2] Все комментарии должны быть написаны на английском языке!**

*Английский язык признан языком международной разработки. Если Вы не знаете как будет слово на английском языке — посетите translate.google.ru. Если Вы вообще не понимаете английского языка — Вам не место в программировании.*

**[1.5.3.3] Предпочитайте использование комментариев типа «//», вплоть до многострочных комментариев.**

Пример:

    // Comment spanning  
    // more than one line  

**Следует использовать данный стиль комментариев ввиду того, что комментарии вида «/\* \*/» обычно используются при отладке. Также обязательно должен быть пробел между «//» и последующими комментариями. Каждое предложение комментариев должно начинаться с заглавной буквы — это необходимо для систем автоматического построения документации.*

**[1.5.3.4] Комментарии должны быть там, где объект которые они комментируют.**

Пример:

    while ( true )  
    {  
        // Do something  
        something( );  
    }  
    
    // Но не!  
    while ( true )  
    // Do something  
    {  
        something( );  
    }  

*Данное правило призвано недопустить разрыв комментариями логической структуры кода.*

**[1.5.3.5] Комментарии объявления класса и методов должны следовать соглашениям JavaDoc.**

*Соглашения JavaDoc признаются стандартом и также применяются и в сообществе С/С++. См. Doxygen для более детальных рекомендаций.*

## Список использованных источников ##

- Нотация iLLi выпуска от 7 апреля 2010 года.
- Code Complete, Steve McConnel – Microsoft Press
- Programming in C++, Rules and Recommenations, M Henricson, e. Nyquist, Ellemtel (Swedish telecom). http://www.doc.ic.ac.uk/lab/cplus/c%2b%2b.rules/.
- Wildfire C++ Programming Style, Keith Gabryelski, Wildfire Communications Inc. http://www.wildfire.com/~ag/Engineering/Development/C++Style/.
- C++ Coding Standard, Todd Hoff. http://www.possibility.com/Cpp/CppCodingStandard.html. 
- Doxygen documentation system. http://www.stack.nl/~dimitri/doxygen/index.html.
- Crytek coding rules.

## Специальные благодарности ##
- Малых Денису Александровичу и Дейнеге Василию Михайловичу за многолетнюю поддержку нотации iLLi.
- Всем тем, кто создает и поддерживает свои собственные соглашения по кодированию. И куда мы могли намеренно или нет подсмотреть при создании этого документа