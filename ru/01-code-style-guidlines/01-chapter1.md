*В квадратных скобках приведена структурная нумерация правил нотации для ссылок на них. Предыдущая сквозная нумерация упразднена как неэффективная.*

# Часть 1. Требования к оформлению кода: #

## 1.1. Основные рекомендации ##

**[1.1.1] Любое нарушение нотации позволяется тогда и только тогда, когда это улучшает читаемость.**

*Основная цель нотации улучшить читаемость кода, а следовательно его понимание и возможности поддержки, и в общем — качество кода. Невозможно охватить все аспекты и варианты использования в общем руководстве, поэтому разработчик должен быть гибок.*

**[1.1.2] Правила могут быть нарушены в том и только в том случае, если нарушивший их может четко объяснить, зачем он это сделал.**

*Попытка создания нотации заключается не в том, чтобы утвердить какой-то определенный стиль программирования в мыслях людей. Опытные программисты могут захотеть адаптировать рекомендации под свой собственный стиль, но это требует чтобы каждый кто пытается делать это, ознакомился и понимал нотацию, а это обычно заставляет людей думать о стиле программирования и воплощать свои личные амбиции на этом поле.*

## 1.2. Соглашения по наименованию ##

### 1.2.1. Общие соглашения по наименованию ###

**[1.2.1.1] Имена, определяющие типы, должны быть в смешанном стиле заглавных и строчных букв, начинаться с заглавной буквы.**

Пример: `Line, SavingsAccount`

*Данное правило следует из общих правил наименований принятых в сообществе С++.*

**[1.2.1.2] Имена переменных должны быть в смешанном стиле заглавных и строчных букв, начинаться с прописной буквы.**

Пример: `line, savingsAccount`

*Данное правило следует из общих правил наименований принятых в сообществе С++.*

**[1.2.1.3] Имена констант (а также имена элементов перечислений) должны писаться полностью заглавными буквами с использованием символа подчеркивания «_» для разделения слов.**

Пример: `MAX_ITERATIONS, COLOR_RED, PI`

*Данное правило следует из общих правил наименований принятых в сообществе С++. В общем случае же использование подобных констант должно быть минимизировано. Во многих случаях, сделать функцию, которая возвращает значение, будет лучшим выбором.*

    int getMaxIterations( )
    {
        return 25;
    }

*Эта форма также легка в прочтении, но кроме того создает общий интерфейс между значениями класса.*

**[1.2.1.4] Имена функций и методов должны быть глаголами, быть записаны в смешанном стиле заглавных и строчных букв, начинаться со строчной буквы.**

Пример: `getName( ), computeTotalWidth( )`

*Данной правило следует из общих правил наименований принятых в сообществе С++. Вообще данное правило идентично с правилом наименования переменных, однако, во-первых, переменные и функции имеют разную природу, во-вторых, современные средства разработки (IDE) позволяют их различать. Кроме того, переменные необходимо именовать именами существительными, а функции - глаголами.*

**[1.2.1.5] Имена пространств имен должны записываться исключительно строчными буквами.**

Пример: `model::analyzer, io::iomanager, common::math::geometry`

*Это обычная практика, принятая в сообществе С++.*

**[1.2.1.6] Имена типов шаблона должны записываться одной заглавной буквой.**

Пример:  

`
template < class T > …  
template < class C, class D > …  
`

*Обычная практика, принятая в сообществе С++. Это позволяет выделить шаблонные имена из всех остальных наименований. Однако современные средства проектирования также позволяют выделять данный класс объектов.*

**[1.2.1.7] Аббревиатуры и акронимы не могут быть записаны полностью заглавными буквами, когда используются в наименованиях.**

Пример:  

`
exportHtmlSource( ); // NOT: exportHTMLSource( );  
openDvdPlayer( ); // NOT: openDVDPlayer( );  
`

*Использование всех заглавных букв будет создавать конфликты с правилами, которые были указаны выше. Например переменные таких типов по правилам должны были бы называться dVD, hTML и т.д. что очевидно не очень хорошо читается. Вторая проблема представлена в примере — когда такое имя соединяется с другим, читаемость кода резко понижается.*

**[1.2.1.8] Глобальные переменные всегда должны предваряться оператором «::».**

Пример: `::mainWindow.open( ), ::applicationContext.getName( )`

*В общем случае следует избегать использования глобальных переменных — лучше использовать объекты типа singleton.*

**[1.2.1.9] Переменные класса (структуры) должны начинаться с символа подчеркивания и удовлетворять общим требованиям именования переменных.**

Пример:  

`
class SomeClass  
{  
private:  
    int _length;  
}
`

*В отличие от имени и типа, область видимости переменной — одна из важнейших особенностей. Отличие переменных класса путем добавления символа подчеркивания позволяет легко отделять их от локальных (временных) переменных. Это важно, потому что поля класса имеют большее значение, нежели локальные переменные методов, поэтому должны отделяться специальным образом.*

*Побочные эффект такого наименование проявляется в элегантном решении проблемы с поиском подходящих имен для переменных сеттеров и конструкторов:*

`
void setDepth( int depth )  
{  
    _depth = depth;  
}
`

*Вопрос где ставить подчеркивание — сначала или вконце? Обе практики широко используются. На наш взгляд использование префикса предпочтительнее — ввиду большего обращения внимания программиста.*

*Следует однако понимать, что выделение переменных по областям видимости иногда является спорным вопросом. Однако, такая практика получает все большее распространение и становится все более и более похожей на правила в профессиональной среде.*

**[1.2.1.10] Единичные временные переменные должны иметь то же имя, что и их тип.**

Пример:  

`
void setTopic( Topic* topic )  
    // NOT: void setTopic( Topic* value )  
    // NOT: void setTopic( Topic* aTopic )  
    // NOT: void setTopic( Topic* t )  
`

`
void connect( Database* database )  
    // NOT: void connect( Database* db )  
    // NOT: void connect( Database* oracleDB )  
`

*Данное правило призвано уменьшить сложность путем уменьшения количества используемых слов и выражений. Это также позволяет предположить тип переменной по ее имени. Если в каких-то случаях кажется, что очень сложно следовать этому правилу — то это является СЕРЬЕЗНЫМ индикатором того, что имя типа выбрано плохо.*

*Не единичные временные переменные имеют роль. Такие переменные именуются комбинацией роли и типа:*

`
Point pointStarting, pointCenter;  
Name nameLogin;  
`

**[1.2.1.11] Все имена должны быть написаны на английском языке!**

Пример: `fileName; // NOT: filNavn`

*Английский язык — предпочитаемый язык для интернациональной разработки. Если не знаете как русское (или на ином языке) слово будет по английски — НЕ ПОЛЕНИТЕСЬ СХОДИТЬ на translate.google.ru и перевести слово. Непременным должно быть и то, что Вы знаете что значит слово.*

**[1.2.1.12] Переменные с большой областью видимости должны иметь длинные имена, в противовес переменным с маленькой областью видимости, для которых предпочтительны короткие имена.**

*Имена локальных переменных, которые используются для временного хранения или в качестве индексов, лучше делать короткими. Программист читающих подобные перменные должен понимать их назначение из нескольких строк. Обычные имена для таких переменных: целочисленные (индексы) i, j, k, m, n; строковые — c и d.*

**[1.2.1.13] Имя объекта должно быть неявным и не использоваться в названии метода.**

Пример: `line.getLength( ); // NOT: line.getLineLength( )`

*Последнее кажется логичным при объявлении класса, однако излишне при использование, в чем можно убедится в примере*

### 1.2.2. Частные соглашения по наименованию ###

**[1.2.2.1] Слова «set»/«get» должны использоваться тогда, когда получается доступ непосредственно к атрибуту.**

Пример:  

`
employee.getName( );  
employee.setName( name );  
`

`
matrix.getElement( 2, 4 );  
matrix.setElement( 2, 4, value );  
`

*Обычная практика, принятая в сообщество С++. В языке Java это соглашение более или менее является стандартным.*

**[1.2.2.2] Слово «compute» должно использоваться тогда, когда в методе что-то вычисляется.**

Пример:  

`
valueSet->computeAverage( );  
matrix->computeInverse( );  
`

*Дайте читающему понять, что данная операция может быть затратна с точки зрения времени выполнения, и если это делается часто — стоит подумать о кэшировании. Правильное использование этого соглашения увеличивает читаемость.*

**[1.2.2.3] Слово «find» должно использоваться в методах, где происходит поиск чего-либо.**

Пример:  

`
vertex.findNearestVertex( );  
matrix.findMinElement( );  
`

*Дайте понять читающему что этот метод просто производит поиск и вовлекает в это минимум вычислений. Правильное использование данного соглашения повышает читаемость кода.*

**[1.2.2.4] Слово «initiate» должно использоваться тогда, когда объект или концепция инициализируется.**

Пример:  

`
printer.initiateFontSet( );  
`

*Аббревиатура init не должна использоваться.*

**[1.2.2.5] Переменные, представляющие собой элементы пользовательского интерфейса (GUI) должны иметь суффикс типа компонента.**

Пример:  

`
mainWindow, propertiesDialog, widthScale, loginText, leftScrollbar, mainForm, fileMenu, minLabel, exitButton, yesToogle …  
`

*Увеличивает читаемость кода ввиду того, что дает читающему понимание типа объекта и его свойств.*

**[1.2.2.6] В объектах, представляющих собой коллекции должно использоваться множественное число.**

Пример:  

`
vector<Point> points;  
int values[];  
`

*Увеличивает читаемость кода ввиду того, что дает немедленное понимание типа объекта и возможных операций над его элементами.*

**[1.2.2.7] Когда требуется определить переменную, содержащую количество чего-либо, мы рекомендуем использовать постфикс «Count».**

Пример: `pointsCount, linesCount`

*На наш взгляд увеличивает читаемость кода*

**[1.2.2.8] Для определения индексных (итерационных) переменных, мы рекомендуем использовать префикс «i» («j», «k», ... ).**

Пример: `iTable, jEmployee`

*На наш взгляд увеличивает читаемость кода*

**[1.2.2.9] Итерационные (индексные) переменные для простых типов должны назваться i, j, k, …**

Пример:  

`
for ( int i = 0; i < nTables; ++i )  
{  
    …  
}  
`

`
for ( vector<MyClass>::iterator i = list.begin( ); i != list.end( ); ++i )  
{  
    …  
}  
`

*Это соглашение также математического происхождения. Имена j, k, … должны использоваться ТОЛЬКО для вложенных циклов.*

**[1.2.2.10] Префикс «is» должен применяться только для логических переменных и функций.**

Пример:  

`
isSet, isVisible, isFinished( ), isFound( ), isOpen( )
`

*Общая практика, принятая в сообществе С++ и частично используемая в Java. Использование префикса is решает общую проблему наименования логических переменных имеющих значение статуса или флага.*

*Имеется несколько альтернатив, которые иногда лучше подходят к ситуации и могут быть использованы. Эти слова «has», «can» и «should»:*

`
bool hasLicense( );  
bool canEvaluate( );  
bool shouldSort( );  
`

**[1.2.2.11] Общепринятые имена должны соответствовать общепринятым операциям.**

Пример:  

`
get/set/put, add/remove,  
create/destroy, start/stop,  
insert/delete, increment/decrement,  
old/new, begin/end, first/last, up/down,  
min/max, next/prev, open/close, show/hide,  
suspend/resume, …
`

*Уменьшает сложность благодаря симметрии.*

**[1.2.2.12] Следует избегать аббревиатур и акронимов в именах.**

Пример:  

`
computeAverage( ); // NOT: compAvg( );
`

*Следует иметь ввиду два типа слов. Первые — это слова из словаря. Такие слова никогда не могут появляться в именах в виде аббревиатур. Нельзя писать:*

`
cmd вместо command  
cp вместо copy  
pt вместо point  
comp вместо compute  
init вместо initialize  
…
`

*Второй тип — словосочетания из специфичной предметной области, которые более широко известны в виде своих акронимов. Такие фразы должны быть записаны ввиде акронимов. Нельзя писать:*

`
HypertextMarkupLanguage вместо html  
CentralProcessingUnit вместо cpu  
PriceEarningRatio вместо pe  
…
`

**[1.2.2.13] Следует избегать именование указателей.**

Пример:

`
Line* line;  
    // NOT: Line* pLine  
    // NOT: Line* linePtr;  
`

*Многие переменные в С/С++ являются указателями, поэтому иногда это правило сложно выполнить. Современные средства разработки позволяют выделать указатели из общего числа имен. Только если реальный тип объекта имеет существенное значение, указатель можно выделить в имени.*

**[1.2.2.14] Следует избегать отрицающих имен логических значений.**

Пример:  

`
bool isError; // NOT: isNoError  
bool isFound; // NOT: isNotFound  
`

*Проблема возникает тогда, когда подобное имя используется рядом с оператором «не», поэтому результат получается дважды отрицающим. Сразу не ясно что значит «!isNotFound».*

**[1.2.2.15] Имена элементов перечисления должны содержать префикс общего типа.**

Пример:  

`
enum Colors  
{  
    COLOR_RED,  
    COLOR_GREEN,  
    COLOR_BLUE  
}  
`

*Дополнительная информация позволяет понять где находится объявление, какие константы с каким связаны, а также какую концепцию представляют константы. Другой подход (применительно к C#) состоит в том, чтобы всегда ссылаться на значение через тип: Color::RED, Airline::AIR_FRANCE, …*

*Важно. Имя типа перечисления должно быть множественным числом, как enum Colors {…}. Единственное число enum Color {…} может выглядеть как объявление типа, но глупо в использовании.*

**[1.2.2.16] Классы исключение должны содержать суффикс «Exception».**

Пример:  

`
class AccessException  
{  
    …  
}  
`

*Классы исключений не являются главной частью архитектуры приложения, и именование их подобных образом позволяет выделять их из других классов.*

## 1.3. Именование файлов ##

### 1.3.1. Файлы исходного кода ###

**[1.3.1.1] Название заголовочных файлов должно иметь расширение «.h» (реже «.hpp»). Название файлов реализации должно иметь расширение «.cpp» (для чистого С - «.c» ).**

Пример: `MyClass.h, MyClass.cpp`

*Общепринятый стандарт С++.*

**[1.3.1.2] Класс должен быть объявлен в заголовочном файле и определен в файле реализации, имена которых совпадают с именем класса.**

Пример: `MyClass.h, MyClass.cpp`

*Данное соглашение призвано облегчить поиск файлов классов по имени. Единственное исключение из этого правила состоит в том, что шаблонные классы должно и объявляться и определяться в заголовочном файле.*

**[1.3.1.3] Все определения должны находится в файле реализации.**

Пример:  

`
class MyClass  
{  
public:  
    int getValue( ) { return _value; } // NO!  
    …  
private:  
    int _value;  
}  
`

*Заголовочные файлы должны объявлять интерфейс, файлы реализации — реализовывать его. В процессе поиска реализации программист должен точно знать, где искать реализацию, а где интерфейс.*

**[1.3.1.4] Содержимое файла должно укладываться в 80 столбцов.**

*80 столбцов обычное разрешение для редакторов, эмуляторов терминала, принтеров и дебаггеров, поэтому файлы, которыми пользуются несколько человек должны удовлетворять этому требованию. Это улучшает читаемость благодаря тому, что разные программисты не вставляют лишних переносов строк.**

**[1.3.1.5] Следует избегать специальные символов, таких как TAB и разрыв страницы.**

*Такие символы могут создать лишние проблемы для редакторов, принтеров, эмуляторов терминалов или дебаггеров, когда используются многими программистами на разных платформах.*

*Единственное исключение из этого правила, которое является собственным правилом — использовать TAB для организации структуры программы. В таких случаях ВСЕГДА используется TAB равный 4 пробелам.*

**[1.3.1.6] Всегда, когда Вы разбиваете строку на несколько — это должно быть очевидным.**

Пример:  

`
totalSum = a + b + c +  
           d + e;  
`

`
function ( param1, param2,  
           param3 );
`

`
setText( “Long line split”  
         “into to parts” );  
`

`
for ( int iTable = 0; iTable < nTables;  
      iTable += tableStep )  
{  
    …  
}  
`

*Разбивка строки нужна тогда, когда она превышает 80 символов, разрешенных в предыдущем правиле. Сложно дать строгое правило как разбивать строку, поэтому следует иметь ввиду следующие общие рекомендации:*

- Переносить после запятой
- Переносить после оператора
- Выравнивать строку относительно начала выражения к которому она принадлежит

### 1.3.2. Подключение файлов и выражения #include ###

**[1.3.2.1] Заголовочные файлы должны иметь защиту от повторного включения.**

Пример:  

`
\#ifndef COM_COMPANY_MODULE_CLASSNAME_H  
\#define COM_COMPANY_MODULE_CLASSNAME_H  
…  
\#endif // COM_COMPANY_MODULE_CLASSNAME_H  
`

*Конструкция нужна для исключения ошибок компиляции при повторном включении. Соглашение по наименованию использует расположение файла в дереве исходных кодов и предотвращает конфликт имен.*

*Никогда нельзя использовать конструкции которые предлагает определенный комплятор (например cl от Microsoft):*

`
// NOT: #pragma once
`

**[1.3.2.2] Операции включения должны быть отсортированы и сгруппированы. Сортировка осуществляется по иерархической позиции файлов в системе начиная с самых низкоуровневых. Следует оставлять пустую строку между группами файлов.**

Пример:  

`
\#include <fstream>  
\#include <iomanip>  
`

`
\#include <qt/qbutton.h>  
\#include <qt/qtextfield.h>  
`

`
\#include “com/company/ui/PropertiesDialog.h”  
\#include “com/company/ui/MainWindow.h”  
`

*Кроме того, что данное соглашение позволяет читающему увидеть отдельные файлы, оно также дает понимание того, какие модули используются.*

**[1.3.2.3] Выражения включения могут находится ТОЛЬКО в начале файла.**

*Обычная практика. Позволяет избежать различных побочных эффектов компиляции, когда операции включения скрыты где-то в исходном коде.*

## 1.4. Выражения ##

### 1.4.1. Типы ###

**[1.4.1.1] Типы, которые относятся только к одному определенному файлу, могут быть объявлены внутри него.**

*Обеспечивает скрытие информации.*

**[1.4.1.2] Части класса должны быть отсортированы по видимости в следующем порядке: public, protected, private. Все спецификаторы должны быть объявлены явно. Не следует писать только спецификаторы, когда секция отсутствует.**

*Правило сортировки - «самые доступные первыми». Это надо для того, чтобы человек, который просто хочет использовать класс остановился при прочтении когда дойдет до секций protected/private.*

**[1.4.1.3] Преобразование типов должно осуществляться только явно. Никогда не полагайтесь на встроенных механизмы преобразования.**

Пример:  

`
floatValue = static_cast< float >( intValue );  
    // NOT: floatValue = intValue  
`

*Благодаря этому соглашению можно избежать использование других типов. Следует помнить, что в С++ можно перегрузить любой оператор, в том числе присваивания и неявного приведения типов — поэтому неявное приведение может привести совершенно не к тем результатам, которые хотелось.*

### 1.4.2. Переменные ###

**[1.4.2.1] Переменные всегда должны определяться там, где объявляются.**

*Это правило направлено на то, чтобы переменные были валидными всегда. Иногда это сделать невозможно, как например*

`
int x, y, z;  
getCenter( &x, &y, &z );  
`

*В таких случаях разрешает оставить их неинициализированными вместо того, чтобы давать им какие-нибудь посторонние значения.*

**[1.4.2.2] Переменные никогда не должны иметь двойной смысл.**

*Улучшает читаемость кода благодаря тому, что все концепции понимаются однозначно. Уменьшает вероятность ошибки из-за побочных эффектов.*

**[1.4.2.3] Использование глобальных переменных следует минимизировать.**

*В С++ нет явной необходимости в использовании глобальных переменных. Аналогичное верно и для глобальных функций или переменных области видимости файла.*

**[1.4.2.4] Переменные класса НИКОГДА нельзя объявлять как public.**

*Концепция сокрытия информации и инкапсуляции в С++ нарушается, когда появляются открытые переменные. Используйте private переменные и функции аксессоры. Единственное исключение из этого файла — классы представляющие собой исключительно структуры данных, без поведения (т.е. структуры языка С). В таком случае следует делать переменные класса открытыми.*

*Внимание. Ключевое слово struct оставлено в С++ для совместимости с С и только. В С++ нет особого различия между struct и class. Поэтому следует использовать struct только тогда, когда это простая структура данных без поведения (функций).*

**[1.4.2.5] Указатели и ссылки С++ должны находится сразу после типа, нежели перед именем.**

Пример:  

`
float* x; // NOT: float *x;  
int& y; // NOT: int &y;  
`

*Указательность и ссылочность — это скорее свойство типа, нежели имени. С-программисты используют обратный подход, но в сообществе С++ это строгое правило.*

**[1.4.2.6] Неявная проверка на 0 не должна использоваться. Исключения — логические значения.**

Пример:  

`
if ( 0 != linesCount ) // NOT: if ( linesCount )  
if ( 0.0 != value ) // NOT: if ( value )  
`

*Это не обязательно в стандарте С++ ввиду того, что 0 целых и вещественных типов реализован как бинарный 0, однако это дает немедленное понимание используемого типа.*

*Также следует помнить, что указатель следует проверять на 0 тоже явно, а еще лучше с помощью макроопределения NULL.*

**[1.4.2.7] Переменные должны объявляться в минимально возможной области видимости.**

*Сохранение операций над переменной в небольщой области видимости увеличивает контроль над прямыми и побочными эффектами использования переменной.*

### 1.4.3. Циклы ###

**[1.4.3.1]  Только выражения контроля цикла могут быть включены в конструкцию for().**

Пример:  

`
sum = 0;  
for ( i = 0; i < 100; ++i )  
    sum += value[ i ];  
`

`
// NOT: for ( i = 0, sum = 0; i < 100; ++i ) sum += value[ i ];  
`

*Улучшает читаемость и возможность поддержки. Проводит четкую грань между управляющими и обрабатываемыми переменными.*

**[1.4.3.2] Переменные цикла должны определяться непосредственно перед циклом.**

Пример:  

`
isDone = false;  
while ( !isDone )  
{  
    …  
}  
`

`
// NOT: bool isDone = false;  
//	  …  
//	  while ( !isDone )  
//	  {  
//		…  
//	  }  
`

**[1.4.3.3] Следует избегать циклов do-while.**

*Циклы do-while менее читаемы, нежели обычные циклы while и for ввиду того, что условие находится внизу. Читающий должен просмотреть все тело цикла для того, чтобы понять что в нем происходит.*

*Также, циклы do-while не требуются. Любой цикл do-while может быть переписан в обычные циклы while и for. Уменьшение числа конструкций также улучшает читаемость кода.*

**[1.4.3.4] Следует использовать конструкции break и continue с осторожностью.**

*Эти инструкции должны использоваться только тогда, когда это улучшает читаемость кода.*

**[1.4.3.5] Для бесконечных циклов должно использоваться форма while( true ).**

Пример:  

`
while ( true )  
{  
    …  
}  
`

`
for ( ; ; ) // NO!  
while ( 1 ) // NO!  
`

*Проверка на 1 ненужна и непонятна. Форма for (;;) не читаема, и не видится как бесконечный цикл.*

### 1.4.4. Условия ###

**[1.4.4.1] Следует избегать очень больших условий. Вместо этого лучше использовать логическую переменную.**

Пример:  

`
bool isFinished = ( iElement < 0 ) || ( iElement > maxElement );  
bool isRepeatedEntry = iElement = lastElement;  
if ( isFinished || isRepeatedEntry )  
{  
    …  
}  
`
`
// NOT:  
if ( ( iElement < 0 ) || ( iElement > maxElement ) ||  
     iElement == lastElement )  
{  
    …  
}  
`

*Благадаря присваиванию логическим переменным — получаем автоматическое документирование кода. Такая конструкция легка в прочтении, понимании и поддержке.*

**[1.4.4.2] Требуемое значение должно находится в части if, ошибочное — в части else.**

Пример:

`
bool isOk = readFile( fileName );  
if ( isOk )  
{  
    …  
}  
else  
{  
    …  
}  
`

*Данное правило позволяет избежать нарушения обычного потока команд. Это важно как для читаемости, так и для производительности.*

**[1.4.4.3] Следует разбивать условия на несколько линий.**

Пример:

`
if ( isDone )  
    doCleanup( );  
`

`
// NOT: if ( isDone ) doCleanup( );  
`

*Это нужно для целей отладки. Когда написано в одну строку сложно определить дебаггером — истинно условие или ложно.*

**[1.4.4.4] Следует избегать выполнения каких либо операций в условиях.**

Пример:

`
File* fileHandle = open( fileName, “w” );  
if ( NULL == fileHandle )  
{  
    …  
}  
`

`
// NOT:  
if ( NULL == ( fileHandle = open( fileName, “w” ) ) )  
{  
    …  
}  
`

*Условия с выполнение операций в них очень сложны в прочтении. Также не следует забывать и о возможных ошибках из-за неправильной расстановки знаков «=».*

### 1.4.5. Прочие требования ###

**[1.4.5.1] Следует избегать использования в коде магических чисел, магических строк и прекодированных включей. Когда необходимо ввести какое-то число — лучше объявить его как именованную константу, элемент перечисления или вообще переменную.**

*Если значение не имеет какого-либо важного самостоятельного значения, введение именованной константы повышает читаемость кода. Другой подход состоит в введении метода, который возвращает требуемое значение.*

**[1.4.5.2] Вещественный константы должны быть записаны с десятичной точкой и хотя бы одним знаком после нее.**

Пример:

`
double total = 0.0;	// NOT: double total = 0;  
double speed = 3.0e8;	// NOT: double speed = 3e8;  
`

`
double sum = ( a + b ) * 10.0;  
`

*Это подчеркивает различную природу целых и вещественных чисел. Математически эти две модели различны и имеют несовпадающие концепции.*

**[1.4.5.3] Вещественные константы должны быть записаны с знаком перед десятичной точкой.**

Пример:

`
double total = 0.5; // NOT: double total = .5;  
`

*Система чисел и выражений в С++ заимствована из математики, поэтому следует следовать математическим соглашениям. Также, 0.5 куда более читаемо, нежели .5. Также это исключает путаницу с целочисленным 5.*

**[1.4.5.4] Функции всегда должны объявлять возвращаемое значение.**

Пример:

`
int getValue( ) // NOT getValue( )
`

*Если не задано явно, С++ считает что тип возвращаемого значения — int. Программисты должны избегать использование этой возможности, потому что начинающие программисты могут про нее не знать.*

**[1.4.5.5] Нельзя использовать goto.**

*Выражения goto нарушают идеи структурированного кода. Единственное исключение из правила состоит в том, чтобы обеспечить выход из сложной вложенной конструкции.*

**[1.4.5.6] Следует определить макроопределение NULL (или аналогичное) и использовать его для операций с указателями вместо «0».**

*Улучшает читаемость кода.*

## 1.5. Макет и комментарии ##

### 1.5.1. Макет ###

**[1.5.1.1] Принять отступ 4. Организовывать его посредством TAB.**

Пример:

`
for ( i = 0; i < nElements; ++i )  
    a[ i ] = 0;  
`

*Отступ в 1 мал для отображения структуры кода. Отступы более 4 могут повлечь нечитаемость глубоко вложенных конструкций и увеличить шанс разбиение строки. Обычно употребимые отступы 2 и 4. Следует придерживаться 4.*

**[1.5.1.2] Блочные структуры должны придерживаться следующего соглашения.**

Пример:

`
while ( !done )  
{  
    doSomething( );  
    done = moreToDo( );  
}  
`
`
// NOT  
while ( !done ) {  
    doSomething( );  
    done = moreToDo( );  
}  
`

`
// NOT  
while ( !done )  
  {  
    doSomething( );  
    done = moreToDo( );  
  }  
`

**[1.5.1.3] Объявления класса должны быть в следующей форме.**

Пример:

`
class SomeClass : public BaseClass  
{  
public:  
    …  
`

`
protected:  
    …  
`

`
private:  
    …  
};  
`

*Это соглашение наследует предыдущее.*

**[1.5.1.4] Объявление методов (функций) должны быть в следующей форме**

Пример:

`
void someMethod( )  
{  
    …  
}  
`

*Это соглашение наследует правило [1.5.1.2].*

**[1.5.1.5] Конструкции условия должны быть записаны в следующей форме:**

Пример:

`
if ( condition )  
{  
    statements;  
}  
`

`
if ( condition )  
{  
    statements;  
}  
else  
{  
    statements;  
}  
`

`
if ( condition )  
{  
    statements;  
}  
else if ( condition )  
{  
    statements;  
}  
else  
{  
    statements;  
}  
`

*Также наследуется общее правило оформления.*

**[1.5.1.6] Цикл for должен оформляться в следующем виде:**

Пример:

`
for ( initialization; condition; update )  
{  
    statements;  
}  
`

**[1.5.1.7] Пустой цикл for должен иметь следующий вид:**

Пример:

`
for ( initialization; condition; update ) ;  
`

**[1.5.1.8] Цикл while должен иметь следующий вид:**

Пример:

`
while ( condition )  
{  
    statements;  
}  
`

**[1.5.1.9]* Цикл do-while должен иметь следующий вид:**

Пример:

`
do  
{  
    statements;  
} while ( condition );  
`

**[1.5.1.10] Инструкция выбора switch должна иметь следующий вид:**

Пример:

`
switch ( condition )  
{  
case ABC:  
    statements;  
    // fallthrough  
`

`
case DEF:  
    statements;  
    break;  
`

`
case XYZ:  
    statements;  
    break;  
`

`
default:  
    statements;  
    break;  
};  
`

**[1.5.1.11] Инструкция try-catch должна иметь следующий вид:**

Пример:

`
try  
{  
    statements;  
}  
catch ( Exception& exception )  
{  
    statements;  
}  
`

**[1.5.1.12] Единичные выражения в блоках if-else, for и while могут быть записаны без блочных скобок.**

Пример:

`
if ( condition )  
    statement;  
`

`
while ( condition )  
    statement;  
`

`
for ( initialization; condition; update )  
    statement;
`

*Общее правило состоит в том, что блочный скобки стоит ставить всегда. Однако, блочные скобки — это конструкция языка, которая группирует несколько выражений. Скобки для одного выражения излишни.*

### 1.5.2. Пробелы ###

**[1.5.2.1] Пробелами должны выделяться: обычные операторы, зарезервированные слова С++, то что следует за запятыми (но не перед запятой — типографское правило), двоеточия (кроме конструкций case), после точки с запятой, круглые скобки, квадратные скобки, угловые скобки.**

Пример:

`
a = ( b + c ) * d; // NOT: a=(b+c)*d  
`

`
while ( true ) // NOT: while(true)  
`

`
doSomething( a, b, c, d ); // NOT: doSomething(a,b,c,d);  
`

`
case 100: // NOT: case 100 :  
`

`
a = ( bool ) ? b : c;  
`

`
for ( i = 0; i < 10; ++i ) // NOT: for(i=0;i<10;++i)  
`

`
template< class T > // NOT: template<class T>  
`

`
a[ i ] = 10; // NOT: a[i]=10;  
`

*Следует показывать отдельные объекты путем выделения их пробелами. Сложно дать полный список рекомендаций по этому правилу.* 

**[1.5.2.2] Логические блоки кода должны разделяться пустой линией.**

Пример:

`
Matrix4x4 matrix = new Matrix4x4( );
`

`
double cosAngle = Math.cos( angle );  
double sinAngle = Math.sin( angle );  
`

`
matrix.setElement( 1, 1,  cosAngle );  
matrix.setElement( 1, 2,  sinAngle );  
matrix.setElement( 2, 1, -sinAngle );  
matrix.setElement( 2, 2,  cosAngle );  
`

`
multiply( matrix );  
`

*Улучшает читаемость кода благодаря логическому разделению блоков кода.*

**[1.5.2.3] Переменные при объявлении могут быть выравненными.**

Пример:

`
AsciiFile* file;  
int        nPoints;  
float      x, y;  
`

*Улучшает читаемость. Легче увидеть переменные.*

**[1.5.2.4] Следует использовать выравнивание всегда — когда это повышает читаемость кода. Иногда даже отступая от некоторых других правил — главное чтоб это не вредило производителности и ошибко-безопасности.**

Пример:

`
if      ( a == lowValue )    computeSomething( );  
else if ( a == mediumValue ) computeSomethingElse( );  
else if ( a == highValue )   computeSomethingElseYet( );  
`

`
value = ( potential        * oilDensity )   / constant1 +  
        ( depth            * waterDensity ) / constant2 +  
        ( zCoordinateValue * gasDensity )   / constant3;  
`

`
minPosition     = computeDistance( min,     x, y, z );  
averagePosition = computeDistance( average, x, y, z );  
`

`
switch ( value )  
{  
case PHASE_OIL:   strcpy( phase, “oil” );   break;  
case PHASE_WATER: strcpy( phase, “Water” ); break;  
case PHASE_GAS:   strcpy( phase, “Gas” );   break;  
};  
`

*Существует несколько различных мест, где правильное использование выравниваний может существенно улучшить читаемость кода.* 

### 1.5.3. Комментарии ###

**[1.5.3.1] Хитрый код должен не комментироваться, а писаться правильно.**

*В общем, использование комментариев следует минимизировать путем создания самодокументируемого кода путем выбора правильных имен и четкой логической структурой.*

*Комментировать следует только контракт интерфейсов, и лучше в системах документирования кода (Wiki, например).*

**[1.5.3.2] Все комментарии должны быть написаны на английском языке!**

*Английский язык признан языком международной разработки. Если Вы не знаете как будет слово на английском языке — посетите translate.google.ru. Если Вы вообще не понимаете английского языка — Вам не место в программировании.*

**[1.5.3.3] Предпочитайте использование комментариев типа «//», вплоть до многострочных комментариев.**

Пример:

`
// Comment spanning  
// more than one line  
`

**Следует использовать данный стиль комментариев ввиду того, что комментарии вида «/\* \*/» обычно используются при отладке. Также обязательно должен быть пробел между «//» и последующими комментариями. Каждое предложение комментариев должно начинаться с заглавной буквы — это необходимо для систем автоматического построения документации.*

**[1.5.3.4] Комментарии должны быть там, где объект которые они комментируют.**

Пример:

`
while ( true )  
{  
    // Do something  
    something( );  
}  
`

`
// NOT!  
while ( true )  
// Do something  
{  
    something( );  
}  
`

*Данное правило призвано недопустить разрыв комментариями логической структуры кода.*

**[1.5.3.5] Комментарии объявления класса и методов должны следовать соглашениям JavaDoc.**

*Соглашения JavaDoc признаются стандартом и также применяются и в сообществе С/С++. См. Doxygen для более детальных рекомендаций.*

## Список использованных источников ##

- Нотация iLLi выпуска от 7 апреля 2010 года.
- Code Complete, Steve McConnel – Microsoft Press
- Programming in C++, Rules and Recommenations, M Henricson, e. Nyquist, Ellemtel (Swedish telecom). http://www.doc.ic.ac.uk/lab/cplus/c%2b%2b.rules/.
- Wildfire C++ Programming Style, Keith Gabryelski, Wildfire Communications Inc. http://www.wildfire.com/~ag/Engineering/Development/C++Style/.
- C++ Coding Standard, Todd Hoff. http://www.possibility.com/Cpp/CppCodingStandard.html. 
- Doxygen documentation system. http://www.stack.nl/~dimitri/doxygen/index.html.
- Crytek coding rules.

## Специальные благодарности ##
- Малых Денису Александровичу и Дейнеге Василию Михайловичу за многолетнюю поддержку нотации iLLi.
- Robert P.J. за важный вклад в указанные выше источники.
- Компании Geotechnical Software Services за вдохновление на написание этого документа, полученное при прочтении их стиля кодированния.
