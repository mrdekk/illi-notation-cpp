*В квадратных скобках приведена структурная нумерация правил нотации для ссылок на них. Предыдущая сквозная нумерация упразднена как неэффективная.*

# Часть 1. Требования к оформлению кода: #

## 1.1. Основные рекомендации ##

**[1.1.1] Любое нарушение нотации позволяется тогда и только тогда, когда это улучшает читаемость.**

*Основная цель нотации улучшить читаемость кода, а следовательно его понимание и возможности поддержки, и в общем — качество кода. Невозможно охватить все аспекты и варианты использования в общем руководстве, поэтому разработчик должен быть гибок.*

**[1.1.2] Правила могут быть нарушены в том и только в том случае, если нарушивший их может четко объяснить, зачем он это сделал.**

*Попытка создания нотации заключается не в том, чтобы утвердить какой-то определенный стиль программирования в мыслях людей. Опытные программисты могут захотеть адаптировать рекомендации под свой собственный стиль, но это требует чтобы каждый кто пытается делать это, ознакомился и понимал нотацию, а это обычно заставляет людей думать о стиле программирования и воплощать свои личные амбиции на этом поле.*

## 1.2. Соглашения по наименованию ##

### 1.2.1. Общие соглашения по наименованию ###

**[1.2.1.1] Имена, определяющие типы, должны быть в смешанном стиле заглавных и строчных букв, начинаться с заглавной буквы.**

Пример: `Line, SavingsAccount`

*Данное правило следует из общих правил наименований принятых в сообществе С++.*

**[1.2.1.2] Имена переменных должны быть в смешанном стиле заглавных и строчных букв, начинаться с прописной буквы.**

Пример: `line, savingsAccount`

*Данное правило следует из общих правил наименований принятых в сообществе С++.*

**[1.2.1.3] Имена констант (а также имена элементов перечислений) должны писаться полностью заглавными буквами с использованием символа подчеркивания «_» для разделения слов.**

Пример: `MAX_ITERATIONS, COLOR_RED, PI`

*Данное правило следует из общих правил наименований принятых в сообществе С++. В общем случае же использование подобных констант должно быть минимизировано. Во многих случаях, сделать функцию, которая возвращает значение, будет лучшим выбором.*

`int getMaxIterations( )  
{  
    return 25;  
}  `

*Эта форма также легка в прочтении, но кроме того создает общий интерфейс между значениями класса.*

**[1.2.1.4] Имена функций и методов должны быть глаголами, быть записаны в смешанном стиле заглавных и строчных букв, начинаться со строчной буквы.**

Пример: `getName( ), computeTotalWidth( )`

*Данной правило следует из общих правил наименований принятых в сообществе С++. Вообще данное правило идентично с правилом наименования переменных, однако, во-первых, переменные и функции имеют разную природу, во-вторых, современные средства разработки (IDE) позволяют их различать. Кроме того, переменные необходимо именовать именами существительными, а функции - глаголами.*

**[1.2.1.5] Имена пространств имен должны записываться исключительно строчными буквами.**

Пример: `model::analyzer, io::iomanager, common::math::geometry`

*Это обычная практика, принятая в сообществе С++.*

**[1.2.1.6] Имена типов шаблона должны записываться одной заглавной буквой.**

Пример:  

`
template < class T > …  
template < class C, class D > …  
`

*Обычная практика, принятая в сообществе С++. Это позволяет выделить шаблонные имена из всех остальных наименований. Однако современные средства проектирования также позволяют выделять данный класс объектов.*

**[1.2.1.7] Аббревиатуры и акронимы не могут быть записаны полностью заглавными буквами, когда используются в наименованиях.**

Пример:  

`
exportHtmlSource( ); // NOT: exportHTMLSource( );  
openDvdPlayer( ); // NOT: openDVDPlayer( );  
`

*Использование всех заглавных букв будет создавать конфликты с правилами, которые были указаны выше. Например переменные таких типов по правилам должны были бы называться dVD, hTML и т.д. что очевидно не очень хорошо читается. Вторая проблема представлена в примере — когда такое имя соединяется с другим, читаемость кода резко понижается.*

**[1.2.1.8] Глобальные переменные всегда должны предваряться оператором «::».**

Пример: `::mainWindow.open( ), ::applicationContext.getName( )`

*В общем случае следует избегать использования глобальных переменных — лучше использовать объекты типа singleton.*

**[1.2.1.9] Переменные класса (структуры) должны начинаться с символа подчеркивания и удовлетворять общим требованиям именования переменных.**

Пример:  

`
class SomeClass  
{  
private:  
    int _length;  
}
`

*В отличие от имени и типа, область видимости переменной — одна из важнейших особенностей. Отличие переменных класса путем добавления символа подчеркивания позволяет легко отделять их от локальных (временных) переменных. Это важно, потому что поля класса имеют большее значение, нежели локальные переменные методов, поэтому должны отделяться специальным образом.*

*Побочные эффект такого наименование проявляется в элегантном решении проблемы с поиском подходящих имен для переменных сеттеров и конструкторов:*

`
void setDepth( int depth )  
{  
    _depth = depth;  
}
`

*Вопрос где ставить подчеркивание — сначала или вконце? Обе практики широко используются. На наш взгляд использование префикса предпочтительнее — ввиду большего обращения внимания программиста.*

*Следует однако понимать, что выделение переменных по областям видимости иногда является спорным вопросом. Однако, такая практика получает все большее распространение и становится все более и более похожей на правила в профессиональной среде.*

**[1.2.1.10] Единичные временные переменные должны иметь то же имя, что и их тип.**

Пример:  

`
void setTopic( Topic* topic )  
    // NOT: void setTopic( Topic* value )  
    // NOT: void setTopic( Topic* aTopic )  
    // NOT: void setTopic( Topic* t )  
`

`
void connect( Database* database )  
    // NOT: void connect( Database* db )  
    // NOT: void connect( Database* oracleDB )  
`

*Данное правило призвано уменьшить сложность путем уменьшения количества используемых слов и выражений. Это также позволяет предположить тип переменной по ее имени. Если в каких-то случаях кажется, что очень сложно следовать этому правилу — то это является СЕРЬЕЗНЫМ индикатором того, что имя типа выбрано плохо.*

*Не единичные временные переменные имеют роль. Такие переменные именуются комбинацией роли и типа:*

`
Point pointStarting, pointCenter;  
Name nameLogin;  
`

**[1.2.1.11] Все имена должны быть написаны на английском языке!**

Пример: `fileName; // NOT: filNavn`

*Английский язык — предпочитаемый язык для интернациональной разработки. Если не знаете как русское (или на ином языке) слово будет по английски — НЕ ПОЛЕНИТЕСЬ СХОДИТЬ на translate.google.ru и перевести слово. Непременным должно быть и то, что Вы знаете что значит слово.*

**[1.2.1.12] Переменные с большой областью видимости должны иметь длинные имена, в противовес переменным с маленькой областью видимости, для которых предпочтительны короткие имена.**

*Имена локальных переменных, которые используются для временного хранения или в качестве индексов, лучше делать короткими. Программист читающих подобные перменные должен понимать их назначение из нескольких строк. Обычные имена для таких переменных: целочисленные (индексы) i, j, k, m, n; строковые — c и d.*

**[1.2.1.13] Имя объекта должно быть неявным и не использоваться в названии метода.**

Пример: `line.getLength( ); // NOT: line.getLineLength( )`

*Последнее кажется логичным при объявлении класса, однако излишне при использование, в чем можно убедится в примере*

### 1.2.2. Частные соглашения по наименованию ###

**[1.2.2.1] Слова «set»/«get» должны использоваться тогда, когда получается доступ непосредственно к атрибуту.**

Пример:  

`
employee.getName( );  
employee.setName( name );  
`

`
matrix.getElement( 2, 4 );  
matrix.setElement( 2, 4, value );  
`

*Обычная практика, принятая в сообщество С++. В языке Java это соглашение более или менее является стандартным.*

**[1.2.2.2] Слово «compute» должно использоваться тогда, когда в методе что-то вычисляется.**

Пример:  

`
valueSet->computeAverage( );  
matrix->computeInverse( );  
`

*Дайте читающему понять, что данная операция может быть затратна с точки зрения времени выполнения, и если это делается часто — стоит подумать о кэшировании. Правильное использование этого соглашения увеличивает читаемость.*

**[1.2.2.3] Слово «find» должно использоваться в методах, где происходит поиск чего-либо.**

Пример:  

`
vertex.findNearestVertex( );  
matrix.findMinElement( );  
`

*Дайте понять читающему что этот метод просто производит поиск и вовлекает в это минимум вычислений. Правильное использование данного соглашения повышает читаемость кода.*

**[1.2.2.4] Слово «initiate» должно использоваться тогда, когда объект или концепция инициализируется.**

Пример:  

`
printer.initiateFontSet( );  
`

*Аббревиатура init не должна использоваться.*

**[1.2.2.5] Переменные, представляющие собой элементы пользовательского интерфейса (GUI) должны иметь суффикс типа компонента.**

Пример:  

`
mainWindow, propertiesDialog, widthScale, loginText, leftScrollbar, mainForm, fileMenu, minLabel, exitButton, yesToogle …  
`

*Увеличивает читаемость кода ввиду того, что дает читающему понимание типа объекта и его свойств.*

**[1.2.2.6] В объектах, представляющих собой коллекции должно использоваться множественное число.**

Пример:  

`
vector<Point> points;  
int values[];  
`

*Увеличивает читаемость кода ввиду того, что дает немедленное понимание типа объекта и возможных операций над его элементами.*

**[1.2.2.7] Когда требуется определить переменную, содержащую количество чего-либо, мы рекомендуем использовать постфикс «Count».**

Пример: `pointsCount, linesCount`

*На наш взгляд увеличивает читаемость кода*

**[1.2.2.8] Для определения индексных (итерационных) переменных, мы рекомендуем использовать префикс «i» («j», «k», ... ).**

Пример: `iTable, jEmployee`

*На наш взгляд увеличивает читаемость кода*

**[1.2.2.9] Итерационные (индексные) переменные для простых типов должны назваться i, j, k, …**

Пример:  

`
for ( int i = 0; i < nTables; ++i )  
{  
    …  
}  
`

`
for ( vector<MyClass>::iterator i = list.begin( ); i != list.end( ); ++i )  
{  
    …  
}  
`

*Это соглашение также математического происхождения. Имена j, k, … должны использоваться ТОЛЬКО для вложенных циклов.*

**[1.2.2.10] Префикс «is» должен применяться только для логических переменных и функций.**

Пример:  

`
isSet, isVisible, isFinished( ), isFound( ), isOpen( )
`

*Общая практика, принятая в сообществе С++ и частично используемая в Java. Использование префикса is решает общую проблему наименования логических переменных имеющих значение статуса или флага.*

*Имеется несколько альтернатив, которые иногда лучше подходят к ситуации и могут быть использованы. Эти слова «has», «can» и «should»:*

`
bool hasLicense( );  
bool canEvaluate( );  
bool shouldSort( );  
`

**[1.2.2.11] Общепринятые имена должны соответствовать общепринятым операциям.**

Пример:  

`
get/set/put, add/remove,  
create/destroy, start/stop,  
insert/delete, increment/decrement,  
old/new, begin/end, first/last, up/down,  
min/max, next/prev, open/close, show/hide,  
suspend/resume, …
`

*Уменьшает сложность благодаря симметрии.*

**[1.2.2.12] Следует избегать аббревиатур и акронимов в именах.**

Пример:  

`
computeAverage( ); // NOT: compAvg( );
`

*Следует иметь ввиду два типа слов. Первые — это слова из словаря. Такие слова никогда не могут появляться в именах в виде аббревиатур. Нельзя писать:*

`
cmd вместо command  
cp вместо copy  
pt вместо point  
comp вместо compute  
init вместо initialize  
…
`

*Второй тип — словосочетания из специфичной предметной области, которые более широко известны в виде своих акронимов. Такие фразы должны быть записаны ввиде акронимов. Нельзя писать:*

`
HypertextMarkupLanguage вместо html  
CentralProcessingUnit вместо cpu  
PriceEarningRatio вместо pe  
…
`

**[1.2.2.13] Следует избегать именование указателей.**

Пример:

`
Line* line;  
    // NOT: Line* pLine  
    // NOT: Line* linePtr;  
`

*Многие переменные в С/С++ являются указателями, поэтому иногда это правило сложно выполнить. Современные средства разработки позволяют выделать указатели из общего числа имен. Только если реальный тип объекта имеет существенное значение, указатель можно выделить в имени.*

**[1.2.2.14] Следует избегать отрицающих имен логических значений.**

Пример:  

`
bool isError; // NOT: isNoError  
bool isFound; // NOT: isNotFound  
`

*Проблема возникает тогда, когда подобное имя используется рядом с оператором «не», поэтому результат получается дважды отрицающим. Сразу не ясно что значит «!isNotFound».*

**[1.2.2.15] Имена элементов перечисления должны содержать префикс общего типа.**

Пример:  

`
enum Colors  
{  
    COLOR_RED,  
    COLOR_GREEN,  
    COLOR_BLUE  
}  
`

*Дополнительная информация позволяет понять где находится объявление, какие константы с каким связаны, а также какую концепцию представляют константы. Другой подход (применительно к C#) состоит в том, чтобы всегда ссылаться на значение через тип: Color::RED, Airline::AIR_FRANCE, …*

*Важно. Имя типа перечисления должно быть множественным числом, как enum Colors {…}. Единственное число enum Color {…} может выглядеть как объявление типа, но глупо в использовании.*

**[1.2.2.16] Классы исключение должны содержать суффикс «Exception».**

Пример:  

`
class AccessException  
{  
    …  
}  
`

*Классы исключений не являются главной частью архитектуры приложения, и именование их подобных образом позволяет выделять их из других классов.*
