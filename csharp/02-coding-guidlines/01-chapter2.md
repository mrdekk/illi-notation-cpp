# Часть 2. Требования к стилю программирования. #

## 2.1. Общие замечания #

**[2.1.1]. см. пункт [1.1.1]**

**[2.1.2]. см. пункт [1.1.2]**

## 2.2. Наследование ##

**[2.2.1] Отношение «есть разновидность» должно быть смоделировано через наследование, отношение «имеет» - через содержание.**

Пример:

    class B : A // B “is-a” A
    {
        …
    }

    class B
    {
    	private A _a; // B “has-a” A
    }
    
**[2.2.2] Следует применять наследование только в том случае, если у наследника изменяется поведение, но не данные**

Пример:

	class Enemy 
	{
		public virtual void RunAI( );
		…
	}
	
	class Boss : Enemy
	{
		public override void RunAI( );
		…
	}
	
Но не

	class Enemy
	{
		public Enemy( )
		{
			_hitpoints( 100 );
		}
		
		protected int _hitpoints;
	}
	
	class FatEnemy : Enemy
	{
		public FatEnemy( ) 
		{ 
			_hitpoints = 200; 
		}	
	}

**[2.2.3] Следует избегать обратного преобразования (downcasting).**

Пример:

    derived = ( DerivedClass )base;

*Необходимость обратного преобразования свидетельствует о недостатках архитектуры. Хорошо написанный код C# не должен полагаться на ветвление основанное на типе объекта. («если объект А такого-то типа то сделать это, иначе то»). Лучше использовать виртуальные функции.*

## 2.3. Разное ##

**[2.3.1] Функции, которые могут быть реализованы с использованием открытого интерфейса класса, лучше не делать методами.**

*Это может означать то, что логически такая функция является функцией другой сущности. Например, функция поиска пути в графе в общем не является функцией класса графа. Возможно, стоит в таком случае создать специальный класс поиска пути, т.к. в процессе поиска будет собрана дополнительная информация.*

*Например, у вас есть класс "граф". Требуется реализовать функциональность поиска пути. Например, с помощью алгоритмы Дейкстры или A*. Однако, кроме самого пути еще неплохо было бы знать длину этого пути. И кроме того, в ходе алгоритм может сохранять какое-то свое состояние. Таким образом, целесообразнее выделить такой поиск пути не в виде функции, а в виде отдельного класса, например, DejkstraSearch или AStarSearch. Таким образом, найденные показатели и внутренняя структура будут инкапсулированы и сокрыты.*

**[2.3.2] Различайте наследование и дженерики**

*При выборе того, будет ли класс реализовываться посредством дженериков или наследования следует руководствоваться следующими соображениями:*

1. дженерики должны использоваться для генерации семейств классов, тип объектов которых не влияет на поведение функций этих классов;
2. наследование должно использоваться для создания семейств классов, тип объектов которых влияет на поведение функций создаваемых классов.

## Список использованных источников ##

- Нотация iLLi выпуска от 7 апреля 2010 года.

## Специальные благодарности ##

- Малых Денису Александровичу и Дейнеге Василию Михайловичу за многолетнюю поддержку нотации iLLi.
- Компании Geotechnical Software Services за вдохновление на написание этого документа, полученное при прочтении их рекомендаций кодированния.