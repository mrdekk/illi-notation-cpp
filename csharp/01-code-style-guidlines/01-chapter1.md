*В квадратных скобках приведена структурная нумерация правил нотации для ссылок на них. Предыдущая сквозная нумерация упразднена как неэффективная.*

# Преамбула #

*Язык C# за годы своего существования стал достаточно популярным языком программирования. Однако, при неумелом программировании возникает большая вероятность получить неработоспособные продукт, или хотя бы продукт, который очень сложно поддерживать. Поэтому основной задачей программистов в последнее время становится написание понятного кода, уменьшая его сложность и когнитивное сопротивление. Чтобы помочь этому процессу создаются разнообразные нотации, или стили кодирования. В этой нотации мы предлагаем свое видение проблемы, основанное на нашем опыте.*

# Часть 1. Требования к оформлению кода: #

## 1.1. Основные рекомендации ##

**[1.1.1] Любое нарушение нотации позволяется тогда и только тогда, когда это улучшает читаемость либо понижает сложность.**

*Как уже было указано выше в преамбуле - основная задача этого документа - уменьшить сложность и улучшить читаемость программ. Мы не можем в одном документе охватить полностью все аспекты, которые могут появляться в ходе программирования на C#, поэтому стараемся дать общие рекомендации. Иногда отступления возможны, но следует понимать, что это не роскошь или преференция.*

**[1.1.2] Правила могут быть нарушены в том и только в том случае, если нарушивший их может четко объяснить, зачем он это сделал.**

*Прежде чем нарушать нотацию стоит с ней ознакомится. Все предложенные правила "выстраданы" на собственном опыте, и мы уверяем Вас, они того стоят. Однако, если вдруг мы где-то ошиблись или Вы настолько ниндзя, что глубоко понимаете правила и знаете некоторые способы их обхода, которые впрочем не нарушают основной цели нотации (меньшая сложность и большая читаемость), то Вы вправе поступить по своему. Но только в том случае, если Вы полностью понимаете и отдаете себе отчет в последствиях.*

**[1.1.3] Правила не "вырублены в граните" а являются предметом обсуждения.**

*Все предлагаемые правила - это выжимки из нашего опыта. Однако и мы тоже люди и можем ошибаться. Кроме того, мы можем чего-то и не знать, язык C# достаточно многообразен. Поэтому мы принимаем аргументированные возражения и предложения. Если аргументация нас устроит - мы внесем поправки в нотацию.*

## 1.2. Соглашения по наименованию ##

### 1.2.1. Общие соглашения по наименованию ###

**[1.2.1.1] Имена, определяющие типы, должны быть в смешанном стиле заглавных и строчных букв, начинаться с заглавной буквы.**

Пример: `Line, SavingsAccount`

*Общее правило по наименованию классов в C#.*

**[1.2.1.2] Имена переменных должны быть в смешанном стиле заглавных и строчных букв, начинаться с прописной буквы.**

Пример: `line, savingsAccount`

*Позволяет визуально разделять классы и переменные.*

**[1.2.1.3] Имена констант должны писаться полностью заглавными буквами с использованием символа подчеркивания «_» для разделения слов.**

Пример: `MAX_ITERATIONS, COLOR_RED, PI`

*Данное правило следует из общих правил наименований принятых в C#.*

**[1.2.1.4] Имена функций и методов должны быть глаголами, быть записаны в смешанном стиле заглавных и строчных букв, начинаться со заглавной буквы.**

Пример: `GetName( ), ComputeTotalWidth( )`

*Данной правило следует из общих правил наименований принятых в C#. Для разделения, свойства необходимо именовать именами существительными, а функции - глаголами.*

**[1.2.1.5] Имена пространств имен должны записываться аналогично правилам наименования классов. Если требуется несколько слов, то они разделяются в смешанном виде, начиная с прописной буквы.**

	CoolProject.Model.Analyzer
	CoolProject.IO.Manager 
	CoolProject.Common.Math.Geometry

*Это обычная практика, принятая в C#.*

**[1.2.1.6] Имена типов-дженериков следует именовать также как и классы.**

Пример:  

    Vector< Type >
    Map< Key, Value >

*Это позволяет, во-первых, использовать идентификатор дженериков в коде как обычный класс (в то же время IDE показывают то, что это параметры дженериков). Во-вторых, это сразу дает представление о том, что ожидается в качестве этого параметра. Практику именования параметров одной заглавной буквой следует избегать.*

**[1.2.1.7] Аббревиатуры и акронимы не могут быть записаны полностью заглавными буквами, когда используются в наименованиях.**

Пример:  

    ExportHtmlSource( ); // Но не: ExportHTMLSource( );
    OpenDvdPlayer( ); // Но не: OpenDVDPlayer( );

*Использование всех заглавных букв будет создавать конфликты с правилами, которые были указаны выше. Например переменные таких типов по правилам должны были бы называться dVD, hTML и т.д. что очевидно не очень хорошо читается. Вторая проблема представлена в примере — когда такое имя соединяется с другим, читаемость кода резко понижается.*

**[1.2.1.8] Переменные класса должны начинаться с символа подчеркивания и удовлетворять общим требованиям именования переменных. Исключение из этого правило возможно только в том случае, когда используемый фреймворк использует рефлексию для определения имен.**

Пример:  

    class SomeClass  
    {  
    	private int _length;  

		[Column( name = "SC_WIDTH", ... )]
		private int width;
    }

*В отличие от имени и типа, область видимости переменной — одна из важнейших особенностей. Отличие переменных класса путем добавления символа подчеркивания позволяет легко отделять их от локальных (временных) переменных. Это важно, потому что поля класса имеют большее значение, нежели локальные переменные методов, поэтому должны отделяться специальным образом.*

*Побочные эффект такого наименование проявляется в элегантном решении проблемы с поиском подходящих имен для переменных сеттеров и конструкторов:*

    void SetDepth( int depth )  
    {  
        _depth = depth; // Но не: this.depth = depth;
    }

*Вопрос где ставить подчеркивание — сначала или вконце? Обе практики широко используются. На наш взгляд использование префикса предпочтительнее — ввиду большего обращения внимания программиста.*

*Следует однако понимать, что выделение переменных по областям видимости иногда является спорным вопросом. Однако, такая практика получает все большее распространение и становится все более и более похожей на правила в профессиональной среде.*

**[1.2.1.9] Свойства должны именоваться в смешанном стиле заглавных и прописных букв, начиная с большой буквы!**

Пример:

	class SomeClass
	{
		private int _length;

		public int Length
		{
			set { _length = value; }
			get { return _length; }
		}
	}

*Это правило во-первых следует из общих правил наименований принятых в C#. Во-вторых, позволяет визуально разделять переменные и свойства, даже несмотря на то, что современных IDE умеют показывать что есть что.*

**[1.2.1.10] Все имена должны быть написаны на английском языке!**

Пример: `fileName; // Но не: imyaFaila`

*Английский язык — предпочитаемый язык для интернациональной разработки. Если не знаете как русское (или на ином языке) слово будет по английски — НЕ ПОЛЕНИТЕСЬ СХОДИТЬ на translate.google.ru и перевести слово. Непременным должно быть и то, что Вы знаете что значит слово. Важно упомянуть, что если вы воспользовались google translate, то вы должны убедиться, что выбрали правильный вариант, чтобы "Вызывающий метод" не стал вдруг "Exciting method".*

**[1.2.1.11] Имя объекта должно быть неявным и не использоваться в названии метода.**

Пример: `line.GetLength( ); // Но не: line.GetLineLength( )`

*Последнее кажется логичным при объявлении класса, однако излишне при использование, в чем можно убедится в примере*

### 1.2.2. Частные соглашения по наименованию ###

**[1.2.2.1] Слова «set»/«get» должны использоваться тогда, когда получается доступ непосредственно к атрибуту.**

Пример:  

    employee.GetName( );  
    employee.SetName( name );  
    
    matrix.GetElement( 2, 4 );  
    matrix.SetElement( 2, 4, value );  

*Однако, если это всего лишь доступ к переменной - лучше воспользоваться свойствами*
	
**[1.2.2.2] Используйте слово «initiate» для методов инициализаторов, «shutdown» для деинициализаторов.**

Пример:

	printer.Initiate( )
	printer.Shutdown( )
	
*Аббревиатуру init лучше использовать, когда в названии метода есть что-то еще.*

Пример:

	printer.Initiate( )
	printer.InitFontSet( ... ) 


**[1.2.2.3] Переменные, представляющие собой элементы пользовательского интерфейса (GUI) должны иметь суффикс типа компонента.**

Пример:  

    mainWindow, propertiesDialog, widthScale, loginText, 
    leftScrollbar, mainForm, fileMenu, minLabel, exitButton, 
    yesToogle …  

*Это лучше, чем использовать префикс, т.к. дает указание на функциональное предназначение объекта, нежели на его тип.*

**[1.2.2.4] В объектах, представляющих собой коллекции должно использоваться множественное число.**

Пример:  

    Vector<Point> points;  
    int values[];  

*Кажется логичным для всех, кто знает английский язык. Кроме того, позволяет писать красивые и краткие инструкции циклов, вида:*

Пример

	foreach ( Point point in Points )

**[1.2.2.5] Когда требуется определить переменную, содержащую количество чего-либо, мы рекомендуем использовать постфикс «Count».**

Пример: `pointsCount, linesCount`

*На наш взгляд увеличивает читаемость кода*

**[1.2.2.6] Немного об индексных переменных**

*Вообще индексные переменные следует именовать привычными для многих программистов i, j, k, ... Однако, это допустимо только в тех случаях, когда тело цикла занимает не больше 5-10 строк. В противном случае становится очень сложно понять, что обозначает эта индексная переменная. В таких случаях мы рекомендуем использовать переменные с префиксом i, j, k в качестве индексных.*
 
Пример: 

	for ( int i = 0; i < tablesCount; ++i )
	{
		< 5 - 10 строк кода >
	}
	
	for ( int iPerson = 0; iPerson < personCount; ++iPerson )
	{
		< большой блок кода >
	}

**[1.2.2.7] Общепринятые имена должны соответствовать общепринятым операциям.**

Пример:  

    get/set/put, add/insert/remove,  
    create/destroy, start/stop, initiate/shutdown,  
    inc(rement)/dec(rement),  
    old/new, begin/end, first/last, up/down,  
    min/max, next/prev, open/close, show/hide,  
    suspend/resume, …

*Уменьшает сложность благодаря симметрии.*

**[1.2.2.8] Следует избегать в именах аббревиатур и акронимов которые не являются общеупотребимыми.**

Пример:  

    ComputeAverage( ); // NOT: compAvg( );

*Можно использовать общеупотребимые аббревиатуры.*

**[1.2.2.9] Следует избегать отрицающих имен логических значений.**

Пример:  

    bool isError; // Но не: isNoError  
    bool isFound; // Но не: isNotFound  

*Проблема возникает тогда, когда подобное имя используется рядом с оператором «не», поэтому результат получается дважды отрицающим. Сразу не ясно что значит «!isNotFound».*

**[1.2.2.10] Имена элементов перечисления не должны содержать префикс общего типа.**

Пример:  

    enum Colors  
    {  
        Red,  
        Green,  
        Blue  
    }  

*Важно. Имя типа перечисления должно быть множественным числом, как enum Colors {…}. Единственное число enum Color {…} может выглядеть как объявление типа, но глупо в использовании.*


**[1.2.2.11] Классы исключение должны содержать суффикс «Exception».**

Пример:  

    class AccessException  
    {  
        …  
    }  

*Классы исключений не являются главной частью архитектуры приложения, и именование их подобных образом позволяет выделять их из других классов.*

## 1.3. Именование файлов ##

### 1.3.1. Файлы исходного кода ###

**[1.3.1.1] Название файлов классов должно иметь расширение «.cs».**

Пример: `MyClass.cs`

*Требование C#.*

### 1.3.2. Подключение классов и выражения using ###

**[1.3.2.1] Операции включения должны быть отсортированы и сгруппированы. Сортировка осуществляется по иерархической позиции классов в системе начиная с самых низкоуровневых. Следует оставлять пустую строку между группами файлов.**

Пример:  

    using System.IO;
	using System.Windows;
        
    using CoolProject.UI;
	using CoolProject.Web;  
    
*Кроме того, что данное соглашение позволяет читающему увидеть отдельные файлы, оно также дает понимание того, какие модули используются.*

**[1.3.2.2] Выражения включения могут находится ТОЛЬКО в начале файла.**

*Обычная практика. Позволяет избежать различных побочных эффектов компиляции, когда операции включения скрыты где-то в исходном коде.*

## 1.4. Выражения ##

### 1.4.1. Типы ###

**[1.4.1.1] Части класса должны быть отсортированы по видимости в следующем порядке: public, protected, private. Все спецификаторы должны быть объявлены явно. Не следует писать только спецификаторы, когда секция отсутствует.**

*Правило сортировки - «самые доступные первыми». Это надо для того, чтобы человек, который просто хочет использовать класс остановился при прочтении когда дойдет до секций protected/private.*

### 1.4.2. Переменные ###

**[1.4.2.1] Переменные всегда должны определяться там, где объявляются.**

*Это правило направлено на то, чтобы переменные были валидными всегда.

**[1.4.2.2] Переменные класса НИКОГДА нельзя объявлять как public.**

*Концепция сокрытия информации и инкапсуляции в C# нарушается, когда появляются открытые переменные. Используйте private переменные и функции аксессоры.*

**[1.4.2.3] Переменные должны объявляться в минимально возможной области видимости.**

*Сохранение операций над переменной в небольшой области видимости увеличивает контроль над прямыми и побочными эффектами использования переменной.*

### 1.4.3. Циклы ###

**[1.4.3.1]  Только выражения контроля цикла могут быть включены в конструкцию for().**

Пример:  

    sum = 0;  
    for ( i = 0; i < 100; ++i )  
        sum += value[ i ];  
    
    // Но не: for ( i = 0, sum = 0; i < 100; ++i ) sum += value[ i ];  

*Улучшает читаемость и возможность поддержки. Проводит четкую грань между управляющими и обрабатываемыми переменными.*

**[1.4.3.2] Переменные цикла должны определяться непосредственно перед циклом.**

Пример:  

    isDone = false;  
    while ( !isDone )  
    {  
        …  
    }  
    
    // Но не: 
    //	  bool isDone = false;  
    //	  …  
    //	  while ( !isDone )  
    //	  {  
    //		  …  
    //	  }  


**[1.4.3.3] Для бесконечных циклов должно использоваться форма while( true ).**

Пример:  

    while ( true )  
    {  
        …  
    }  
    
    for ( ; ; ) // NO!  
    while ( 1 ) // NO!  

*Проверка на 1 ненужна и непонятна. Форма for (;;) не читаема, и не видится как бесконечный цикл.*

### 1.4.4. Условия ###

**[1.4.4.1] Следует избегать очень больших условий. Вместо этого лучше использовать логическую переменную.**

Пример:  

    bool isFinished = ( iElement < 0 ) || ( iElement > maxElement );  
    bool isRepeatedEntry = iElement = lastElement;  
    if ( isFinished || isRepeatedEntry )  
    {  
        …  
    }  
    
    // Но не:  
    if ( ( iElement < 0 ) || ( iElement > maxElement ) ||  
         iElement == lastElement )  
    {  
        …  
    }  

*Благодаря присваиванию логическим переменным — получаем автоматическое документирование кода. Такая конструкция легка в прочтении, понимании и поддержке.*

**[1.4.4.2] Следует разбивать условия на несколько линий.**

Пример:

    if ( isDone )  
        DoCleanup( );  
    
    // Но не: if ( isDone ) DoCleanup( );  

*Это нужно для целей отладки. Когда написано в одну строку сложно определить дебаггером — истинно условие или ложно.*

**[1.4.4.3] Следует избегать выполнения каких либо операций в условиях.**

Пример:

    File* fileHandle = Open( fileName, “w” );  
    if ( NULL == fileHandle )  
    {  
        …  
    }  
    
    // Но не:  
    if ( NULL == ( fileHandle = Open( fileName, “w” ) ) )  
    {  
        …  
    }  

*Условия с выполнение операций в них очень сложны в прочтении. Кроме того, оптимизация условия может просто устранить вызов операции, и он никогда не случится*

### 1.4.5. Прочие требования ###

**[1.4.5.1] Следует избегать использования в коде магических чисел, магических строк и прекодированных включений. Когда необходимо ввести какое-то число — лучше объявить его как именованную константу, элемент перечисления или вообще переменную.**

*Если значение не имеет какого-либо важного самостоятельного значения, введение именованной константы повышает читаемость кода. Другой подход состоит в введении метода, который возвращает требуемое значение.*

**[1.4.5.2] Вещественный константы должны быть записаны с десятичной точкой и хотя бы одним знаком после нее.**

Пример:

    double total = 0.0;	// Но не: double total = 0;  
    double speed = 3.0e8;	// Но не: double speed = 3e8;  
    
    double sum = ( a + b ) * 10.0;  

*Это подчеркивает различную природу целых и вещественных чисел. Математически эти две модели различны и имеют несовпадающие концепции.*

**[1.4.5.3] Вещественные константы должны быть записаны с знаком перед десятичной точкой.**

Пример:

    double total = 0.5; // Но не: double total = .5;  

*Система чисел и выражений в C# заимствована из математики, поэтому следует следовать математическим соглашениям. Также, 0.5 куда более читаемо, нежели .5. Также это исключает путаницу с целочисленным 5.*

## 1.5. Макет и комментарии ##

### 1.5.1. Макет ###

**[1.5.1.1] Принять отступ 4. Организовывать его посредством TAB.**

Пример:

    for ( i = 0; i < nElements; ++i )  
        a[ i ] = 0;  

*Отступ в 1 мал для отображения структуры кода. Отступы более 4 могут повлечь нечитаемость глубоко вложенных конструкций и увеличить шанс разбиение строки. Обычно употребимые отступы 2 и 4. Следует придерживаться 4.*

**[1.5.1.2] Блочные структуры должны придерживаться следующего соглашения.**

Пример:

    while ( !done )  
    {  
        DoSomething( );  
        done = MoreToDo( );  
    }  
    
    // Но не  
    while ( !done ) {  
        DoSomething( );  
        done = MoreToDo( );  
    }  
    
    // Но не  
    while ( !done )  
      {  
        DoSomething( );  
        done = MoreToDo( );  
      }  

**[1.5.1.3] Объявления класса должны быть в следующей форме.**

Пример:

    class SomeClass : BaseClass  
    {  
    	public ...
       	...
    
    	protected ...  
        ...
    
    	private ...
        ...
    };  

*Это соглашение наследует предыдущее.*

**[1.5.1.4] Объявление методов (функций) должны быть в следующей форме**

Пример:

    void SomeMethod( )  
    {  
        …  
    }  

*Это соглашение наследует правило [1.5.1.2].*

**[1.5.1.5] Конструкции условия должны быть записаны в следующей форме:**

Пример:

    if ( condition )  
    {  
        statements;  
    }  
    
    if ( condition )  
    {  
        statements;  
    }  
    else  
    {  
        statements;  
    }  
    
    if ( condition )  
    {  
        statements;  
    }  
    else if ( condition )  
    {  
        statements;  
    }  
    else  
    {  
        statements;  
    }  

*Также наследуется общее правило оформления.*

**[1.5.1.6] Цикл for должен оформляться в следующем виде:**

Пример:

    for ( initialization; condition; update )  
    {  
        statements;  
    }  

	foreach ( Type var in vars )
	{
		statements;
	}

**[1.5.1.7] Пустой цикл for должен иметь следующий вид:**

Пример:

    for ( initialization; condition; update ) ;  

**[1.5.1.8] Цикл while должен иметь следующий вид:**

Пример:

    while ( condition )  
    {  
        statements;  
    }  

**[1.5.1.9]* Цикл do-while должен иметь следующий вид:**

Пример:

    do  
    {  
        statements;  
    } while ( condition );  

**[1.5.1.10] Инструкция выбора switch должна иметь следующий вид:**

Пример:

    switch ( condition )  
    {  
   		case ABC:  
        	statements;  
        	// fallthrough  
    
    	case DEF:  
        	statements;  
	        break;  
    
	    case XYZ:  
    	{
    	    statements;  
    	    ... // очень много выражений
    	    statements; 
    	    break;  
	    }
    
    	default:  
    	    statements;  
    	    break;  
    };  

**[1.5.1.11] Инструкция try-catch должна иметь следующий вид:**

Пример:

    try  
    {  
        statements;  
    }  
    catch ( Exception exc )  
    {  
        statements;  
    }  

**[1.5.1.12] Единичные выражения в блоках if-else, for и while могут быть записаны без блочных скобок.**

Пример:

    if ( condition )  
        statement;  
    
    while ( condition )  
        statement;  
    
    for ( initialization; condition; update )  
        statement;

*Общее правило состоит в том, что блочный скобки стоит ставить всегда. Однако, блочные скобки — это конструкция языка, которая группирует несколько выражений. Скобки для одного выражения излишни.*

### 1.5.2. Пробелы ###

**[1.5.2.1] Пробелами должны выделяться: обычные операторы, зарезервированные слова C#, то что следует за запятыми (но не перед запятой — типографское правило), двоеточия (кроме конструкций case), после точки с запятой, круглые скобки, квадратные скобки, угловые скобки.**

Пример:

    a = ( b + c ) * d; // Но не: a=(b+c)*d  
    
    while ( true ) // Но не: while(true)  
    
    DoSomething( a, b, c, d ); // Но не: DoSomething(a,b,c,d);  
    
    case 100: // Но не: case 100 :  
    
    a = ( bool ) ? b : c;  
    
    for ( i = 0; i < 10; ++i ) // Но не: for(i=0;i<10;++i)  
    
    Worker< Type extends Something > // Но не: Worker<Type extends Something>  
    
    a[ i ] = 10; // Но не: a[i]=10;  

*Следует показывать отдельные объекты путем выделения их пробелами. Сложно дать полный список рекомендаций по этому правилу.* 

**[1.5.2.2] Логические блоки кода должны разделяться пустой линией.**

Пример:

    Matrix4x4 matrix = new Matrix4x4( );
    
    double cosAngle = Math.Cos( angle );  
    double sinAngle = Math.Sin( angle );  
    
    matrix.SetElement( 1, 1,  cosAngle );  
    matrix.SetElement( 1, 2,  sinAngle );  
    matrix.SetElement( 2, 1, -sinAngle );  
    matrix.SetElement( 2, 2,  cosAngle );  
    
    Multiply( matrix );  

*Улучшает читаемость кода благодаря логическому разделению блоков кода.*

### 1.5.3. Комментарии ###

**[1.5.3.1] Хитрый код должен не комментироваться, а писаться правильно.**

*В общем, использование комментариев следует минимизировать путем создания самодокументируемого кода путем выбора правильных имен и четкой логической структурой.*

*Комментировать следует только контракт интерфейсов, и лучше в системах документирования кода (Wiki, например).*

**[1.5.3.2] Предпочитайте использование комментариев типа «//», вплоть до многострочных комментариев.**

Пример:

    // Comment spanning  
    // more than one line  

**Следует использовать данный стиль комментариев ввиду того, что комментарии вида «/\* \*/» обычно используются при отладке. Также обязательно должен быть пробел между «//» и последующими комментариями. Каждое предложение комментариев должно начинаться с заглавной буквы — это необходимо для систем автоматического построения документации.*

**[1.5.3.3] Комментарии должны быть там, где объект которые они комментируют.**

Пример:

    while ( true )  
    {  
        // Do something  
        Something( );  
    }  
    
    // Но не!  
    while ( true )  
    // Do something  
    {  
        Something( );  
    }  

*Данное правило призвано недопустить разрыв комментариями логической структуры кода.*

## Список использованных источников ##

- Нотация iLLi выпуска от 7 апреля 2010 года.

## Специальные благодарности ##
- Малых Денису Александровичу и Дейнеге Василию Михайловичу за многолетнюю поддержку нотации iLLi.
- Всем тем, кто создает и поддерживает свои собственные соглашения по кодированию. И куда мы могли намеренно или нет подсмотреть при создании этого документа